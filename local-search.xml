<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java高性能高并发秒杀系统</title>
    <link href="/2021/10/28/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/10/28/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>本项目从零实现了一个秒杀系统的一些核心功能。</p><p>通过本项目能够学习如何应对大并发、如何利用缓存、如何使用异步、以及如何编写优雅的代码</p><p>关于项目的代码实现，请移步：<a href="https://github.com/Yeefine/Miaosha">代码</a></p><hr><h3 id="系统开发环境以及版本"><a href="#系统开发环境以及版本" class="headerlink" title="系统开发环境以及版本"></a>系统开发环境以及版本</h3><ul><li>操作系统：Windows_10(代码开发)、Centos7(Redis、RabbitMQ部署)</li><li>集成开发工具：IntelliJ IDEA 2020.2.1</li><li>编译环境：JDK_1.8</li><li>数据库：MySQL_5.7</li></ul><hr><h3 id="技术点介绍"><a href="#技术点介绍" class="headerlink" title="技术点介绍"></a>技术点介绍</h3><div class="table-container"><table><thead><tr><th>前端</th><th>后端</th><th>中间件</th></tr></thead><tbody><tr><td>Thymeleaf</td><td>SpringBoot</td><td>RabbitMQ</td></tr><tr><td>Bootstrap</td><td>JSR303</td><td>Redis</td></tr><tr><td>JQuery</td><td>MyBatis</td><td>Druid</td></tr></tbody></table></div><hr><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20211028220310.png" alt=""></h3><hr><h3 id="项目结构设计及实现功能"><a href="#项目结构设计及实现功能" class="headerlink" title="项目结构设计及实现功能"></a>项目结构设计及实现功能</h3><h4 id="1-项目框架搭建"><a href="#1-项目框架搭建" class="headerlink" title="1. 项目框架搭建"></a>1. 项目框架搭建</h4><ul><li><p>Spring Boot环境搭建</p></li><li><p>集成Thymeleaf，Result结果封装</p></li><li><p>集成Mybatis + Druid</p><ul><li><p><strong>报错</strong>：Loading class com.mysql.jdbc.Driver’. This is deprecated`警告处理，jdbc更新。</p><p><strong>处理</strong>：处理：提示信息表明数据库驱动<code>com.mysql.jdbc.Driver</code>已经被弃用了、应当使用新的驱动<code>com.mysql.cj.jdbc.Driver</code>。所以，按照提示更改jdbc.properties配置 <code>com.mysql.jdbc.Driver</code>  改为  <code>com.mysql.cj.jdbc.Driver</code></p></li></ul></li><li><p>集成Jedis + Redis安装 + 通用缓存Key封装（<strong>设计模式中的模板模式</strong>）</p><p>接口 &lt;— 抽象类 &lt;— 实现类 </p><ol><li>接口：规定一些契约</li><li>抽象类：实现一些共通的方法</li><li>实现类：进行一些特殊功能的实现</li></ol></li></ul><h4 id="2-实现登录功能"><a href="#2-实现登录功能" class="headerlink" title="2. 实现登录功能"></a>2. 实现登录功能</h4><ul><li><p>数据库设计</p></li><li><p>明文密码两次MD5处理</p><ol><li><p>用户端：PASS = MD5(明文 + 固定Salt)</p><p><strong>防止用户明文密码在网络上进行传输</strong></p></li><li><p>服务端：PASS = MD5(用户输入 + 随机Salt)</p><p><strong>防止数据库数据泄露，根据MD5值反推回明文密码</strong></p></li></ol></li><li><p>JSR303参数检验 + 全局异常处理器</p><p>将在具体controller方法中进行的参数校验，转变为针对具体类属性的校验(JSR303的注解，可以自定义注解)，当不满足注解要求时抛出异常。针对其他的一些校验处理定义全局异常，其中存储返回的CodeMsg信息，在service方法中进行校验判断并抛出对应信息的全局异常。定义全局异常处理器对这些异常进行捕获处理，并在其中根据不同的异常信息返回不同的错误信息。</p><p>这样对参数的校验，就封装在一个独立的全局异常处理器当中，在 service方法中 或 根据JSR303注解 抛出异常即可，无需在controller方法中进行校验，减少了代码的冗余。</p></li><li><p>分布式Session（同步不同机器上的Session信息）</p><p>根据服务端，把一个token写入到cookie当中，客户端在随后的访问当中携带这个cookie，服务端就通过cookie和token就可以找到token对应的用户。</p><ol><li>首先生成一个对应的UUID作为token，与要同步信息组成<code>(K, V)</code>对。</li><li>将<code>(K, V)</code>存入redis缓存中。</li><li>将token信息存入一个cookie中，并将cookie放入response中。</li><li>controller请求方法可以通过<code>@CookieValue</code>或<code>@RequestParam</code>来获取token值，并通过token从redis中取出同步信息的值。</li></ol><p>我们可以通过上述4中的方式，在controller方法的参数列表获取request、response、token等，在方法内进行处理。但是这样操作，在每个需要处理的方法中都会产生冗余、复杂的参数列表以及处理代码。因此，对处理代码进行封装，并将处理的结果作为 controller方法参数列表可获取的参数，就可以大大减少冗余代码。关键实现类<code>WebMvcConfigurerAdapter</code>，接口<code>HandlerMethodArgumentResolver</code>，方法<code>resolveArgument</code>。</p></li></ul><h4 id="3-实现秒杀功能"><a href="#3-实现秒杀功能" class="headerlink" title="3. 实现秒杀功能"></a>3. 实现秒杀功能</h4><ul><li><p>数据库设计</p></li><li><p>商品列表页</p></li><li><p>商品详情页</p></li><li><p>订单详情页</p><p>dao中需要插入数据的同时返回信息，除了<code>@Insert</code>注解，还需使用<code>@SelectKey</code>注解，不能直接用返回值接收，而是执行完sql语句后，会将对应属性值赋给该对象，通过对象来获取属性值。</p></li></ul><h4 id="4-JMeter压测"><a href="#4-JMeter压测" class="headerlink" title="4. JMeter压测"></a>4. JMeter压测</h4><ul><li><p>JMeter入门</p></li><li><p>自定义变量模拟多用户</p></li><li><p>JMeter命令行使用</p><ol><li>在windows上录好jmx</li><li>命令行：sh jmeter.sh -n -t XXX.jmx -l result.jtl</li><li>把result.jtl导入到jmeter</li></ol><p>redis使用redis-benchmark进行测压</p></li><li><p>Spring Boot打war包</p><ol><li>添加spring-boot-starter-tomcat的provided依赖</li><li>添加maven-war-plugin插件</li><li>启动函数继承<code>SpringBootServletInitializer</code>类，重写<code>configure</code>方法</li></ol></li></ul><h4 id="5-页面优化技术"><a href="#5-页面优化技术" class="headerlink" title="5. 页面优化技术"></a>5. 页面优化技术</h4><ul><li><p>页面缓存 + URL缓存 + 对象缓存（粒度划分不同）</p><ul><li>页面缓存（商品列表页）：这种缓存技术一般用于不会经常变动的信息，并且访问次数比较多的页面，这样就不用了每次都动态加载，缓存时间较短。<ol><li>取缓存</li><li>手动渲染模板</li><li>结果输出</li></ol></li><li>URL缓存（商品详情页）：这里的URL 缓存相当于页面缓存 —— 针对项目中的详情页{goodsId}，不同的详情页，显示不同缓存页面，缓存时间较短。URL缓存其实和页面缓存思路相同，二者的不同在于缓存中加入了URL。其实到这里URL缓存已经很好理解了，只需要在缓存的key中加上URL携带的参数就可以。</li><li>对象缓存：相比页面缓存是更细粒度缓存 + 缓存 更新。对象缓存就是 当用到用户数据的时候，可以从缓存中取出。比如：更新用户密码</li></ul></li><li><p>页面静态化，前后端分离</p><p>将页面缓存到客户的浏览器上，当用户访问页面的时候，直接不与服务器有交互，直接从本地缓存中拿取页面，节省网络流量。实际就是html + ajax。</p><p>非静态化就是，请求发起后，controller方法中处理，并返回新的页面。</p><p>而静态化，访问直接访问用户本地的缓存的html页面 （浏览器会缓存下来静态static下文件），静态资源，然后通过前端ajAx来访问后端，获取页面需要显示的数据返回即可。</p><ol><li><p>常用技术AngularJS、Vue.js</p></li><li><p>优点：利用浏览器的缓存</p><hr></li></ol><ul><li>每一个秒杀订单创建后，存入redis缓存，在判断是否已经秒杀时，不需要访问数据库。</li><li>为了防止一个用户同时发出多个秒杀请求，抢到多个商品，在<code>miaosha_order</code>中建立<code>user_id</code>和<code>goods_id</code>的唯一索引。</li></ul></li><li><p>静态资源优化</p><ol><li>JS / CSS 压缩，减少流量</li><li>多个 JS / CSS 组合，减少连接数</li></ol></li><li><p>CDN优化，就近访问</p></li></ul><p>解决超卖问题：</p><ol><li>数据库加唯一索引：防止用户重复购买</li><li>SQL加库存数量判断：防止库存变成负数</li></ol><h4 id="6-接口优化"><a href="#6-接口优化" class="headerlink" title="6. 接口优化"></a>6. 接口优化</h4><p>思路：减少数据库的访问</p><ol><li><p>系统初始化，把商品库存数量加载到Redis</p></li><li><p>收到请求，Redis预减库存，库存不足，直接返回，否则进入3</p></li><li><p>请求入队，立即返回排队中</p></li><li><p>请求出队，生成订单，减少库存（访问数据库）</p></li><li><p>客户端轮询，是否秒杀成功</p><hr></li></ol><ul><li><p>Redis预减库存减少数据库访问</p></li><li><p>内存标记减少Redis访问</p></li><li><p>RabbitMQ队列缓冲，异步下单，增强用户体验</p></li><li><p>RabbitMQ安装与Spring Boot集成</p><p><strong>发布/订阅模式</strong>：生产者将消息发送到交换机(Exchange)，再由交换机转发到队列，交换机只负责转发消息，不具备存储消息能力，如果没有队列和交换机绑定，或没有符合的路由规则，则消息会被丢失。交换机常见四种类型：</p><ol><li>Direct Exchange(定向）</li><li>Topic Exchange(通配符)</li><li>Fanout Exchange(广播)</li><li>Headers Exchange((K,V))</li></ol></li><li><p>访问Nginx水平扩展</p><p>扩展到多台服务器上，负载均衡配置</p></li><li><p>压测</p></li></ul><h4 id="7-安全优化"><a href="#7-安全优化" class="headerlink" title="7. 安全优化"></a>7. 安全优化</h4><ul><li><p>秒杀接口地址隐藏</p><p>思路：秒杀开始之前，先去请求接口获取秒杀地址</p><ol><li>接口改造，带上 PathVariable 参数</li><li>添加生成地址的接口</li><li>秒杀收到请求，先验证PathVariable</li></ol></li><li><p>数学公式验证码</p><p>思路：点击秒杀之前，先输入验证码，分散用户的请求</p><ol><li><p>添加生成验证码的接口</p></li><li><p>在获取秒杀路径的时候，验证验证码</p></li><li><p>ScriptEngine使用</p><p>BufferedImage生成图片，随机生成数字和运算符号，组成表达式，写入图片，通过输出流传给前端。</p><p>使用ScriptEngine直接可以计算，得到运算表达式的字符串的结果值。</p></li></ol></li><li><p>接口限流防刷</p><p>思路：对接口做限流</p><ol><li>可以用拦截器减少对业务入侵</li></ol></li></ul><hr><h3 id="细节总结"><a href="#细节总结" class="headerlink" title="细节总结"></a>细节总结</h3><ul><li><p>在集成Mybatis和Druid时，报错：<code>Loading class com.mysql.jdbc.Driver&#39;. This is deprecated</code>警告处理，jdbc更新。</p><p>提示信息表明数据库驱动<code>com.mysql.jdbc.Driver</code>已经被弃用了、应当使用新的驱动<code>com.mysql.cj.jdbc.Driver</code>。所以，按照提示更改jdbc.properties配置 <code>com.mysql.jdbc.Driver</code>  改为  <code>com.mysql.cj.jdbc.Driver</code></p></li><li><p><code>td</code>赋值用<code>text</code>、<code>input</code>赋值用<code>val</code>。</p></li><li><p>进行多用户jmeter压测时，每次生成的token.txt，只能供当前的登录和启动使用，当重新登录或服务器重启后，需要重新生成token.txt，因为每次登录的token是由UUid随机生成的，然后将(token，user)存储在redis缓存中，并将token添加到cookie中。若服务器重启，或者用户重新登录，对应的token就会改变。</p></li><li><p>进行压测时，虽然秒杀订单数不会变成负数，但是生成的订单和秒杀订单比规定的数量多</p><p>可能是在处理并发的时候有些逻辑写的有问题，暂时未找到具体出问题的地方，后续进行接口优化后，测试结果正确。</p></li><li><p>用rabbitmq传输MiaoshaMessage的json，MQReceiver端接收不到，普通的json却可以接收</p><p>猜测可能与页面静态化，页面缓存等有关，或是redis服务器状态相关，将redis服务器重启，清空浏览器的缓存后，接收成功。</p></li></ul><hr><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><ol><li><p>登录界面</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20211028220426.png" alt=""></p></li><li><p>商品列表页</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20211028220500.png" alt=""></p></li><li><p>商品详情页</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20211028220536.png" alt=""></p></li><li><p>订单详情页</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20211028220559.png" alt=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客系统</title>
    <link href="/2021/08/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="个人博客系统（Solitude-Blog）"><a href="#个人博客系统（Solitude-Blog）" class="headerlink" title="个人博客系统（Solitude Blog）"></a>个人博客系统（Solitude Blog）</h2><p>Solitude是基于SpringBoot2.x框架，借助Vue.js、Thymeleaf构建的一个简洁美观的传统单体架构博客系统。</p><h3 id="系统开发环境以及版本"><a href="#系统开发环境以及版本" class="headerlink" title="系统开发环境以及版本"></a>系统开发环境以及版本</h3><ul><li>操作系统：Windows_10</li><li>集成开发工具：IntelliJ IDEA 2020.2.1</li><li>编译环境：JDK_1.8</li><li>数据库：MySQL_5.7</li></ul><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Version</th><th style="text-align:center">Env</th><th style="text-align:center">Version</th></tr></thead><tbody><tr><td style="text-align:center">SpringBoot</td><td style="text-align:center">2.3.1RELEASE</td><td style="text-align:center">JDK</td><td style="text-align:center">1.8</td></tr><tr><td style="text-align:center">Mybatis</td><td style="text-align:center">2.1.3</td><td style="text-align:center">MySQL</td><td style="text-align:center">5.7</td></tr><tr><td style="text-align:center">Spring-shiro</td><td style="text-align:center">1.5.2</td><td style="text-align:center">IDEA</td><td style="text-align:center">2020.2</td></tr></tbody></table></div><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>具体实现功能介绍文档，请移步：<a href="https://github.com/Yeefine/BlogSystem/blob/master/function.md">功能介绍</a></p><p>项目源代码，请移步：<a href="https://github.com/Yeefine/BlogSystem">代码</a></p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><ul><li><p>登录页面</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825113301.png" alt=""></p><hr></li><li><p>首页展示</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825113250.png" alt=""></p></li><li><p>文章详细页面</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825113223.png" alt=""></p></li><li><p>后台管理页面</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825143147.png" alt=""></p><hr><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825113327.png" alt=""></p><hr><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825113341.png" alt=""></p><hr><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825143110.png" alt=""></p><hr><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210825143129.png" alt=""></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springMVC小结</title>
    <link href="/2021/07/11/springMVC%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/07/11/springMVC%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul><li>SpringMVC做web开发的框架，实际是spring框架中的一个模块</li><li>SpringMVC的使用就是基于spring的，容器的概念，SpringMVC会创建容器，<code>WebApplicationContext</code>。SpringMVC作为容器是创建和管理控制器对象的，使用<code>@Controller</code>创建控制器对象</li><li>三层和框架的对应<ol><li>SpringMVC：界面层，接受用户请求，显示处理结果</li><li>Spring：业务层，处理业务逻辑的，spring创建Service，Dao，工具类等对象</li><li>MyBatis：持久层，访问数据库的，对数据增删改查</li></ol></li><li>SpringMVC底层访问依然是<code>Servlet-DispatcherServlet(中央调度器)</code><ol><li>创建<code>WebApplicationContext</code>对象，读取配置文件，进而创建控制器对象</li><li>它是一个Servlet，要接受用户的请求，显示处理结果</li></ol></li></ul><h4 id="二、SpringMVC处理web请求"><a href="#二、SpringMVC处理web请求" class="headerlink" title="二、SpringMVC处理web请求"></a>二、SpringMVC处理web请求</h4><ul><li><p>注解</p><ol><li><code>@Controller</code>：创建控制器类的对象，接受请求，处理请求</li><li><code>@RequestMapping</code>：请求映射，把请求绑定到一个方法，让这个方法处理请求<ol><li><code>value</code>：请求的uri地址，唯一值</li><li><code>method</code>：请求的方式，使用<code>RequestMethod</code>类的枚举值，例如，get请求，<code>RequestMethod.GET</code></li></ol></li></ol></li><li><p>接收用户提交的参数</p><ol><li><p><code>HttpServletRequest</code>，<code>HttpServletResponse</code>，<code>HttpSession</code>可以直接出现在处理器方法的参数位置</p></li><li><p>逐个接受参数，处理器方法的形参名和请求中参数名一样。按名称对应赋值</p></li><li><p>解决请求中post方式有中文乱码，使用<strong>过滤器</strong>解决问题。<code>CharacterEncodingFilter</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册声明过滤器，解决post请求乱码的问题--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-comment">&lt;!--设置项目中使用的字符编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-comment">&lt;!--强制请求对象（HttpServletRequest）使用encoding编码的值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-comment">&lt;!--强制应答对象（HttpServletResponse）使用encoding编码的值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">/*：表示强制所有的请求先通过过滤器处理</span><span class="hljs-comment">--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></li></ol></li></ul><ol><li>逐个接收中，请求中参数名和形参名不一样，使用<code>@RequestParam</code>解决问题<ol><li>使用java对象接收请求的参数，要求请求中参数名和属性名一样</li><li>springmvc处理器方法的形参还可以Map，List等集合类型，数组都可以</li></ol></li></ol><ul><li><p>处理器方法的返回值：表示请求的处理结果</p><ol><li><p><code>ModelAndView</code>：表示数据和视图，对视图执行forward</p></li><li><p><code>String</code>：表示视图的，可以逻辑名称，完整视图路径，对视图执行forward</p></li><li><p><code>void</code>：返回值本身不能表示数据和视图，可以响应ajax请求</p></li><li><p><code>对象Object</code>：表示数据的，响应ajax请求</p><p>springmvc处理器方法返回对象，转为json响应ajax步骤</p><ol><li>加入处理java到json转换的工具库：<code>jackson</code></li><li>在springmvc配置文件加入注解驱动<code>&lt;mvc:annotation-driven&gt;</code></li><li>在处理器方法的上面加入<code>@ResponseBody</code></li></ol></li></ol></li><li><p><code>url-pattern</code></p><ul><li>设置中央调度器的url-pattern是<code>/</code>：导致静态资源访问失败都是404，动态资源可以正常访问</li><li><p>第一种解决静态资源访问的方案：</p><ul><li>在springmvc的配置文件中加入<code>&lt;mvc:default-servlet-handler&gt;</code>，<code>&lt;mvc:annotation-driven&gt;</code></li><li>原理：给程序内存增加一个处理器对象，<code>DefaultHttpRequestHandler</code>，让这个对象处理静态资源的访问。</li></ul></li><li><p>第二种处理静态资源：使用的框架中<code>&lt;mvc:resources&gt;</code>标签，由框架自己处理静态资源的访问</p></li></ul></li><li><p>ssm整合开发</p><ul><li>ssm整合有两个容器<ol><li>springmvc的容器：管理controller，视图等对象</li><li>spring的容器：service，dao等对象</li></ol></li><li>创建容器的方式<ol><li>创建springmvc的容器对象：使用的中央调度器<code>DispatcherServlet</code></li><li>创建spring容器对象，使用监听器<code>ContextLoaderListener</code></li></ol></li><li>配置文件<ol><li>springmvc的配置文件</li><li>spring配置文件</li><li>mybatis主配置文件</li><li>数据库的属性配置文件</li></ol></li></ul></li><li><p>核心技术</p><ul><li>转发和重定向<ul><li>转发：<code>forward</code></li><li>重定向：<code>redirect</code></li><li>特点：都不和是解析器一同工作，就当项目中没有视图解析器</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springMVC框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSM框架实现CRM项目</title>
    <link href="/2021/07/11/%E4%BD%BF%E7%94%A8SSM%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0CRM%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/07/11/%E4%BD%BF%E7%94%A8SSM%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0CRM%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="客户关系管理系统（CRM）"><a href="#客户关系管理系统（CRM）" class="headerlink" title="客户关系管理系统（CRM）"></a>客户关系管理系统（CRM）</h3><p>具体实现代码，<a href="https://github.com/Yeefine/CRM">参考于此</a></p><h4 id="系统开发环境以及版本"><a href="#系统开发环境以及版本" class="headerlink" title="系统开发环境以及版本"></a>系统开发环境以及版本</h4><ul><li>操作系统：Windows_10</li><li>集成开发工具：IntelliJ IDEA 2020.2.1</li><li>编译环境：JDK_1.8</li><li>Web服务器：Tomcat_9.0</li><li>数据库：MySQL_5.5.40</li></ul><h4 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h4><ul><li>spring框架</li><li>springmvc框架</li><li>mybatis框架</li><li>maven框架</li></ul><h4 id="系统关键性技术"><a href="#系统关键性技术" class="headerlink" title="系统关键性技术"></a>系统关键性技术</h4><ul><li>Spring+Springmvc+Mybatis三大框架</li><li>Ajax技术</li><li>条件查询结合分页查询</li><li>线索转换</li><li>md5加密加盐</li></ul><h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><ol><li>在创建maven项目后，需要替换原始的web.xml</li><li>在写springmvc的配置文件dispatcherServlet.xml时，注解驱动注意要选择mvc结尾的</li><li>在spring配置文件中创建SqlSessionFactory时，configLocation属性的路径指向要用value（<strong>特殊</strong>）。一般根据name的返回类型判断，String则用value。</li><li>在js中使用el表达式，el表达式一定要套用在字符串中，即加双引号。</li><li>对于动态元素所触发的方法，参数必须套用在字符串当中。</li><li>当<code>key</code>的值是一个可变的变量时，我们不能以<code>json.key</code>的形式取得<code>value</code>，应使用<code>json[key]</code>的取值方式。</li><li>form表单的<code>action</code>以及<code>window.location.href</code>中的路径都不用加<code>/</code>；<code>RequestMapping</code>注解的value要加<code>/</code>；<code>ModelAndView</code>进行重定向或者转发时，在<code>forward:</code>或<code>redirect:</code>后需要加<code>/</code>。</li><li>使用bootstrap的日历和分页组件时，对应的中文字符乱码。日历组件重新创建文件，复制并保存，替换原文件，注意编码格式为utf-8；分页组件目前尚未解决。</li><li>ssm框架中，使用listener加载数据字典时，需注意，ssm中使用spring注解的方式创建对象，监听器在web.xml中最先被执行，因此在监听器方法执行时，无法进行bean的自动注入，使用<code>WebApplication.getBean(xxx.class)</code>来创建对应的对象。</li><li>在进行关联市场活动的操作中，报空指针异常。ajax请求的data格式不是json时，而是一个拼接的字符串，此时controller中对多个id相同的参数(<code>.../xxx.do?id=xxx&amp;id=xxx&amp;id=xxx</code>)的接受，需要使用<code>request.getParameterValues(&quot;id&quot;)</code>来获取数组对象，而不能直接在参数列表加入数组对象。</li></ol><h4 id="部分页面"><a href="#部分页面" class="headerlink" title="部分页面"></a>部分页面</h4><ul><li><p>登录页</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210710213407.png" alt=""></p></li><li><p>市场活动</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210710213627.png" alt=""></p></li><li><p>交易详细信息页</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210710220849.jpg" alt=""></p></li><li><p>交易统计图表页</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210710214006.png" alt=""></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SSM框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring小结</title>
    <link href="/2021/04/30/spring%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/04/30/spring%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-什么是spring"><a href="#1-什么是spring" class="headerlink" title="1. 什么是spring"></a>1. 什么是spring</h4><ul><li>是一个框架，核心技术是ioc，aop，实现解耦合。</li><li>spring是一个容器，容器中存放的是java对象，需要做的是把对象放入到容器中。</li></ul><h4 id="2-怎么使用spring"><a href="#2-怎么使用spring" class="headerlink" title="2. 怎么使用spring"></a>2. 怎么使用spring</h4><ul><li>spring是一个容器，把项目中用的对象放入到容器中</li><li>让容器完成对象的创建，对象之间关系的管理（属性赋值）</li><li>我们在程序中，从容器中获取要使用的对象</li></ul><h4 id="3-怎么样的对象放入容器中"><a href="#3-怎么样的对象放入容器中" class="headerlink" title="3. 怎么样的对象放入容器中"></a>3. 怎么样的对象放入容器中</h4><ul><li><code>dao</code>类，<code>service</code>类，<code>controller</code>类，工具类<ol><li>使用xml配置文件，使用<code>&lt;bean&gt;</code></li><li>注解</li></ol></li><li>spring中的对象默认都是单例的，在容器中叫这个名称的对象只有一个</li></ul><h4 id="4-不放入到spring容器中的对象"><a href="#4-不放入到spring容器中的对象" class="headerlink" title="4. 不放入到spring容器中的对象"></a>4. 不放入到spring容器中的对象</h4><ol><li>实体类对象，实体类数据来自数据库</li><li><code>servlet</code>，<code>listener</code>，<code>filter</code>等</li></ol><h4 id="5-使用spring框架的步骤"><a href="#5-使用spring框架的步骤" class="headerlink" title="5. 使用spring框架的步骤"></a>5. 使用spring框架的步骤</h4><ol><li><p>加入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>创建类：接口，实现类，没有接口的类</p></li><li><p>创建spring的配置文件，使用<code>&lt;bean&gt;</code>声明对象</p></li><li><p>我们使用容器中的对象，通过<code>ApplicationContext</code>接口和它的实现类<code>ClassPathXmlApplicationContext</code>的方法<code>getBean()</code></p></li></ol><h4 id="6-核心技术"><a href="#6-核心技术" class="headerlink" title="6. 核心技术"></a>6. 核心技术</h4><ul><li><p><code>ioc</code>：控制反转</p><ol><li>理论，思想，概念：指导开发人员在容器中，代码之外管理对象，给属性赋值，管理依赖</li><li><code>ioc</code>技术实现使用的<code>di</code>（依赖注入）：开发人员在项目中只需要提供对象的名称，对象的创建、查找、赋值都由容器内部自己实现</li><li><p>spring使用的<code>di</code>的技术，底层使用的是反射机制</p></li><li><p><code>di</code>给属性赋值:</p><ol><li>set注入：spring调用类的set方法实现属性赋值<ol><li>简单类型的set注入，<code>&lt;property name=&quot;属性名&quot; value=&quot;属性的值&quot;/&gt;</code></li><li>引用类型的set注入，<code>property name=&quot;属性名&quot; ref=&quot;bean的id&quot;/&gt;</code></li></ol></li><li>构造注入：spring调用有参数构造方法<ol><li><code>&lt;constructor-arg&gt;</code>的name属性，name表示构造方法的形参名</li><li><code>&lt;constructor-arg&gt;</code>的index属性，index表示构造方法形参的位置，从0开始</li></ol></li></ol></li></ol></li><li><p><code>aop</code>：面向切面编程</p><ul><li>底层是动态代理<ol><li>jdk动态代理<ul><li>使用jdk反射包中的类实现创建代理对象的功能</li><li>要求：目标类必须实现接口</li></ul></li><li>cglib动态代理<ul><li>使用第三方的工具库，实现代理对象的创建</li><li>要求：目标类必须能够继承，不能是final</li><li>原理：就是继承，子类就是代理</li></ul></li></ol></li><li>aop：看作是动态代理的规范化，把实现动态代理的步骤进行了一个规范，定义</li><li>aop作用：<ol><li>在目标类不修改源代码的情况下，增加功能</li><li>减少重复的代码</li><li>专注业务功能的实现</li><li>解耦合：业务功能和日志，事务这些非业务功能的耦合</li></ol></li><li>什么时候考虑使用aop技术<ol><li>当你要给一个系统中存在的类修改功能，但是原有类的功能不完善，但是你还有源代码，使用aop增加功能</li><li>要给项目中的多个类，增加一个相同的功能，使用aop</li><li>给业务方法增加事务，日志输出</li></ol></li><li>aop的实现框架<ol><li><code>spring</code>实现了aop，实现方式是接口</li><li><code>aspectj</code>框架<ol><li>使用注解可以实现aop的功能</li><li>使用xml配置文件中的标签实现aop功能</li></ol></li></ol></li><li>aop中的概念<ol><li><code>aspect</code>：切面，表示给业务方法增加的功能，一般日志输出，事务，权限检查等是切面</li><li><code>pointcut</code>：切入点，是一个或多个<code>JoinPoint</code>的集合，表示切面功能执行的位置</li><li><code>advice</code>：通知，也叫增强，表示切面执行的时间，在方法前，方法后等等</li></ol></li><li><code>aspectj</code>框架的使用<ol><li>表示切面的执行时间，使用的通知注解<ol><li><code>@Before</code>：前置通知，在目标方法之前先执行切面的功能</li><li><code>@AfterReturning</code>：后置通知，在目标方法之后执行的，能够获取到目标方法的返回值</li><li><code>@Around</code>：环绕通知，在目标方法前和后都能增强功能，控制目标方法的访问，修改返回值</li><li><code>@AfterThrowing</code>：异常通知，在目标方法抛出异常后执行的通知</li><li><code>@After</code>：最终通知，总是会被执行的代码</li><li><code>@Pointcut</code>：定义和管理切入点的辅助注解</li><li>代理的使用方式<ol><li>如果目标类有接口，框架使用jdk动态代理</li><li>如果目标类没有接口，默认使用的cglib动态代理</li><li>有接口也可以强制使用cglib动态代理</li></ol></li></ol></li><li>表示切面位置的切入点表达式：<code>execution(访问修饰符 返回值 包名.类名.方法名称(方法的参数) 异常)</code> </li></ol></li></ul></li><li><p>spring整合mybatis</p><ul><li><p>整合的想法：使用spring的ioc核心技术，把mybatis框架中使用的对象交给spring统一创建和管理。spring是容器，存放你项目中要是用的各种对象，例如Service对象，Dao对象，工具类对象等等。</p></li><li><p>交给spring的mybatis对象</p><ol><li><p>数据源DataSource，使用阿里公司的<code>Druid</code>连接池</p></li><li><p>SqlSessionFactory对象，使用的<code>SqlSessionFactoryBean</code>在内部创建的SqlSessionFactory</p></li><li><p>Dao代理对象，使用的<code>MapperScannerConfigurer</code>，在这个类的内部，调用<code>getMapper()</code>，创建接口的Dao对象</p></li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis小结</title>
    <link href="/2021/04/21/MyBatis%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/04/21/MyBatis%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><h4 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1. 三层架构"></a>1. 三层架构</h4><ol><li>界面层（视图层）：完成和用户的交互，接受请求，显示请求的处理结果</li><li>业务逻辑层：计算数据，处理业务逻辑</li><li>数据访问层（持久层）：数据库操作</li></ol><h4 id="2-框架"><a href="#2-框架" class="headerlink" title="2. 框架"></a>2. 框架</h4><ol><li>界面层：SpringMVC</li><li>业务逻辑层：Spring</li><li>数据访问层：MyBatis</li></ol><h4 id="3-mybatis"><a href="#3-mybatis" class="headerlink" title="3. mybatis"></a>3. mybatis</h4><ul><li><p>作用：增强的jdbc，访问数据库，执行增删改查</p></li><li><p>基本步骤</p><ol><li><p>加入maven的依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>创建Dao接口：定义了操作数据的方法</p></li><li><p>创建mapper文件，也叫做sql映射文件：写sql语句的，和接口中方法对应的sql语句</p></li><li><p>创建mybatis的一个主配置文件：1）连接数据库；2）指定mapper文件的位置</p></li><li><p>使用mybatis的对象SqlSession，通过其方法执行sql语句</p></li></ol></li><li><p>使用mybatis的动态代理</p><ul><li><p>什么是动态代理：mybatis帮你创建dao接口的实现类，在实现类中调用SqlSession的方法执行 sql语句</p></li><li><p>使用动态代理方式</p><ol><li>获取SqlSession对象，<code>SqlSessionFactory.openSession()</code></li><li>使用getMapper方法获取某个接口的对象，<code>sqlSession.getMapper(接口.class)</code></li><li>使用dao接口的方法，调用方法就执行了mapper文件中的sql语句</li></ol></li><li><p>使用动态代理方式的要求</p><ol><li>dao接口和mapper文件放在一起，同一个目录</li><li>dao接口和mapper文件名称一致</li><li>mapper文件中的<code>namespace</code>的值是dao接口的全限定名称</li><li>mapper文件中的<code>&lt;select&gt;</code>，<code>&lt;insert&gt;</code>，<code>&lt;update&gt;</code>，<code>&lt;delete&gt;</code>等的id是接口中方法名称</li><li>dao接口中不要使用重载方法，不要使用同名的，不同参数的方法。</li></ol></li><li><p>理解参数</p><p>从java代码中把实际的值传入到mapper文件中</p><ol><li>一个简单类型的参数：<code>#&#123;任意字符&#125;</code></li><li>多个简单类型的参数：使用<code>@Param(&quot;自定义名称&quot;)</code></li><li>使用一个java对象，对象的属性值作为mapper文件中的参数，<code>#&#123;java对象的属性名称&#125;</code></li><li>使用参数的位置，语法<code>#&#123;arg0&#125;, #&#123;arg1&#125;</code>，mybatis3.4之前的版本，使用的是<code>#&#123;0&#125;, #&#123;1&#125;</code></li><li>使用Map作为参数，<code>#&#123;map的key&#125;</code></li></ol></li><li><p><code>#</code>和<code>$</code>的区别</p><ol><li><code>#</code>是占位符，表示列值的，放在等号右侧</li><li><code>$</code>占位符，表示字符串的连接，把sql语句连接成一个字符串</li><li><code>#</code>占位符使用的jdbc指定<code>PreparedStatement</code>对象执行SQL语句，销路好，没有sql注入的风险</li><li><code>$</code>使用的是<code>Statement</code>对象执行sql，效率低，有sql注入的风险</li></ol></li><li><p>mybatis返回结果</p><ul><li><code>resultType</code>：表示sql语句的执行结果，转为的java对象的类型<ol><li>类型的全限定名称</li><li>别名：在mybatis主配置文件定义别名<ol><li>使用<code>&lt;typeAlias&gt;</code></li><li>使用<code>&lt;package name=&#39;包名&#39; /&gt;</code>：类名就是别名</li></ol></li></ol></li><li><code>resultMap</code>：自定义类名和java对象的属性名对应关系</li><li>列名和属性名不一样的解决方式<ol><li>使用列名</li><li>使用resultMap</li></ol></li><li><code>like</code>：<ol><li>在java代码中指定<code>like</code>的内容</li><li>在mapper中拼接<code>like</code></li></ol></li></ul></li><li><p>动态sql：根据条件，能够得到不同的sql语句，使用mybatis的标签，例如if，where，foreach等</p><ul><li><p><code>if</code>：判断条件的，条件为true，就会把if之间的sql加入到主sql之后</p></li><li><p><code>where</code>：<code>&lt;where&gt;</code>标签里面是多个<strong>if</strong>，如果有一个if判断为true，会在sql的后面加入<strong>where</strong>关键字，会去掉无用的and，or等字符</p></li><li><p><code>foreach</code>：循环数组，list集合</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>#&#123;xxx&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>collection：表示接口中的方法参数的类型，如果是数组使用array，如果是list集合使用listitem：自定义的，表示数组和集合成员的变量open：循环开始时的字符close：循环结束时的字符separator：集合成员之间的分隔符</code></pre></li><li><p>sql代码片段：复用部分sql语句</p><ol><li>先定义<code>&lt;sql id=&quot;自定义名称唯一&quot;&gt;sql语句，表名，字段等&lt;/sql&gt;</code></li><li>再使用，<code>&lt;include refid=&quot;id的值&quot;/&gt;</code></li></ol></li></ul></li><li><p>mybatis主配置文件</p><ol><li><p>数据库属性配置文件的使用</p><ol><li>在resources目录中定义一个属性配置文件，<code>xxx.properties</code>，例如，<code>jdbc.properties</code>。在属性配置文件中，定义数据，格式是<code>key=value</code>，key一般使用<code>.</code>做多级目录的</li><li>在mybatis的主配置文件，使用<code>&lt;property&gt;</code>指定文件的位置，在需要使用值的地方，<code>$&#123;key&#125;</code></li></ol></li><li><p>mapper文件的位置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种方式：使用包名</span><span class="hljs-comment">            name：xml文件（mapper文件）所在的包名，这个包中所有xml文件一次都能加载给mybatis</span><span class="hljs-comment">            使用package的要求：</span><span class="hljs-comment">                1. mapper文件名称需要和接口名称一样，区分大小写也一样</span><span class="hljs-comment">                2. mapper文件和dao接口需要再同一目录</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.bjpowernode.dao&quot;</span>/&gt;</span></code></pre></li></ol></li><li><p><code>PageHelper</code>：分页</p><ul><li><p>功能：实现多种数据库的分页，mysql就是代替limit语句的</p></li><li><p>使用步骤：</p><ol><li><p>加入maven依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--PageHelper依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在mybatis主配置文件，加入plugin</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置插件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></code></pre></li><li><p>在查询方式之前，加入PageHelper方法调。</p><pre><code class="hljs java"><span class="hljs-comment">// 加入PageHelper的方法，分页</span><span class="hljs-comment">// pageNum：第几页，从1开始</span><span class="hljs-comment">// pageSize：一页中有多少行数据</span>PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);</code></pre></li></ol></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK动态代理</title>
    <link href="/2021/04/21/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2021/04/21/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h4><p>当一个对象不能直接使用，可以在客户端和目标对象直接创建一个中介，这个中介就是代理</p><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><ol><li>控制访问：在代理中，控制是否可以调用目标对象的方法。</li><li>功能增强：可以在完成目标对象的调用时，附加一些额外的功能，这些额外的功能叫做功能增强。</li></ol><h4 id="3-代理的实现方式"><a href="#3-代理的实现方式" class="headerlink" title="3. 代理的实现方式"></a>3. 代理的实现方式</h4><ol><li>静态代理：代理类是手工实现的java文件，同时代理的目标对象是规定的。<ol><li>优点：容易理解、使用方便</li><li>缺点：在目标类比较多的时候，会产生大量的代理类；当接口改变时，影响的目标类和代理比较多，都需要修改</li></ol></li><li>动态代理：使用反射机制，在程序执行中，创建代理类对象。不用创建类文件，代理的目标类是活动的，可设置的<ol><li>不用创建代理类</li><li>可以给不同的目标随时创建代理</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven小结</title>
    <link href="/2021/04/07/Maven%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/04/07/Maven%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-maven"><a href="#1-maven" class="headerlink" title="1. maven"></a>1. maven</h4><p>​    是一个项目的构建工具</p><h4 id="2-maven的作用"><a href="#2-maven的作用" class="headerlink" title="2. maven的作用"></a>2. maven的作用</h4><ol><li>管理依赖：jar管理的，下载，版本</li><li>构建项目，完成项目代码的编译，测试，打包，部署</li></ol><h4 id="3-maven的使用方式"><a href="#3-maven的使用方式" class="headerlink" title="3. maven的使用方式"></a>3. maven的使用方式</h4><ol><li>独立使用maven：使用maven的各种命令，完成代码的编译，测试，打包等</li><li>结合开发工具使用，一般在idea中使用maven：简单，快捷，不需要记命令</li></ol><h4 id="4-maven的安装"><a href="#4-maven的安装" class="headerlink" title="4. maven的安装"></a>4. maven的安装</h4><ol><li>获取安装包，zip文件</li><li>解压缩文件，到一个目录，非中文目录</li><li>配置环境变量，M2_HOME，它的值是maven的安装目录</li><li>在path中加入<code>%M2_HOME\bin</code></li><li>测试maven的安装，使用<code>mvn -v</code>，查看maven的版本信息</li></ol><h4 id="5-maven的核心概念"><a href="#5-maven的核心概念" class="headerlink" title="5. maven的核心概念"></a>5. maven的核心概念</h4><ol><li><p>约定的目录结构</p><ul><li>项目的目录Hello</li><li><code>src</code>和<code>pom.xml</code>平级</li><li><code>src/main</code><ul><li><code>java</code>：主程序java文件</li><li><code>resources</code>：配置文件</li></ul></li><li><code>src/test</code><ul><li><code>java</code>：测试程序代码</li><li><code>resources</code>：测试使用的配置文件</li></ul></li></ul></li><li><p>坐标（gav）</p><ol><li><code>groupId</code>：组织编码，域名倒写</li><li><code>artifactId</code>：项目名称</li><li><code>version</code>：自定义版本号</li></ol></li><li><p>依赖（dependency）：maven管理依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用依赖吧jar导入到项目中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>仓库</p><ul><li>存放的<code>jar</code>，maven的插件等等</li><li>仓库分类<ul><li>本地仓库：可以在maven安装目录/conf/settings.xml指定，<code>&lt;localRespository&gt;非中文路径，不要有空格&lt;/localRespository&gt;</code></li><li>中央仓库：最权威的，所有资源都在这里</li><li>中央仓库的镜像：分担压力的</li><li>私服：公司的局域网内部使用的</li></ul></li></ul></li><li><p>maven的命令：maven通过命令完成项目的构建</p><ol><li><code>mvn clean</code>：清理</li><li><code>mvn compile</code>：编译<code>src/main/java目录</code>中的程序，把java编译为class文件，并放到<code>target/classes目录</code>中；同时会把<code>src/main/resources/目录</code>中的文件拷贝到<code>target/classes目录</code>中</li><li><code>mvn test-compile</code>：编译<code>src/main/test目录</code>下的java程序，拷贝到<code>target/test-classes目录</code>中</li><li><code>mvn test</code>：可以进行单元测试，使用<code>junit</code>测试<code>src/main/java目录</code>中的程序是否符合要求</li><li><code>mvn package</code>：打包，把程序中<code>src/main/目录</code>下面的java编译后的class和resources中的配置文件放入到一个压缩文件中，javase-jar，web-war</li><li><code>mvn install</code>：把<code>jar</code>，<code>war</code>安装到本机的仓库中</li></ol></li><li><p>maven的生命周期和插件</p><ul><li>生命周期：项目的构建过程，清理、编译、测试、报告、打包、安装、部署</li><li>插件：maven提供的功能，用来执行清理、编译、测试、报告、打包的程序</li></ul></li></ol><h4 id="6-依赖范围"><a href="#6-依赖范围" class="headerlink" title="6. 依赖范围"></a>6. 依赖范围</h4><ol><li><code>compile</code>：默认，在够贱的编译、测试、打包、部署需要</li><li><code>test</code>：只在测试阶段需要</li><li><code>provided</code>：在部署时，由服务器提供，项目本身不需要自带</li></ol><h4 id="7-maven常用设置"><a href="#7-maven常用设置" class="headerlink" title="7. maven常用设置"></a>7. maven常用设置</h4><ol><li><p>maven自己的属性</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span></code></pre></li><li><p>自定义变量</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--自定义变量，表示版本号--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>resource资源插件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!-- 所在的目录 所在的目录 所在的目录--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><span class="hljs-comment">&lt;!-- 包括目录下的 包括目录下的 包括目录下的 .properties,.xml 文件都会扫描到 文件都会扫描到 文件都会扫描到 文件都会扫描到 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-comment">&lt;!--filtering选项 false不启用过滤器， 不启用过滤器， 不启用过滤器， 不启用过滤器， *.property已经起到过滤的作用了 已经起到过滤的作用了 已经起到过滤的作用了 已经起到过滤的作用了 已经起到过滤的作用了--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><ol><li>默认没有使用resources的时候，maven执行编译代码时，会把<code>src/main/resources目录</code>中的文件拷贝到<code>target/classes目录</code>中。对于<code>src/main/java目录</code>下的非java文件不处理，不拷贝到<code>target/classes目录</code>中</li><li>我们的程序有需要把一些文件放置<code>src/main/java目录</code>中，当我在执行java程序时，需要用到<code>scr/main/java目录</code>中的文件。需要告诉maven在<code>mvn compile</code>编译<code>src/main/java目录</code>下的程序时，需要把文件一同拷贝到<code>target/classes目录</code>中。此时就需要在<code>&lt;build&gt;</code>中加入<code>&lt;resources&gt;</code></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery小结</title>
    <link href="/2021/03/30/jQuery%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/03/30/jQuery%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-什么是jQuery？"><a href="#1-什么是jQuery？" class="headerlink" title="1. 什么是jQuery？"></a>1. 什么是jQuery？</h4><p>​    是一个javascript的库，里面有很多的函数</p><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><p>​    可以操作dom对象，事件处理，动画，ajax</p><h4 id="3-jQuery的优点"><a href="#3-jQuery的优点" class="headerlink" title="3. jQuery的优点"></a>3. jQuery的优点</h4><ol><li>免费，开源的</li><li>比较小巧，压缩的版本只有87k大小；</li><li>兼容大多数的浏览器</li><li>文档齐备</li></ol><h4 id="4-对象分类"><a href="#4-对象分类" class="headerlink" title="4. 对象分类"></a>4. 对象分类</h4><ul><li>dom对象：使用js语法创建的对象是dom对象，也是js对象。dom对象可以调用dom方法，属性。</li><li>jQuery对象：使用jQuery语法创建的对象，jQuery独享能调用jQuery函数库中的函数或者属性。jQuery对象是数组，数组中的每个元素是dom对象。</li></ul><h4 id="5-选择器"><a href="#5-选择器" class="headerlink" title="5. 选择器"></a>5. 选择器</h4><ul><li>什么是选择器：就是一个字符串，用来定位dom对象的，就是选择页面中dom对象的条件</li><li><p>基本选择器</p><ul><li>id选择器：语法<code>$(&quot;#id值&quot;)</code></li><li>class选择器：语法<code>$(&quot;.class名称&quot;)</code></li><li>标签选择器：语法<code>$(&quot;标签名称&quot;)</code></li><li>所有选择器：语法<code>$(&quot;*&quot;)</code></li><li>组合选择器：语法<code>$(&quot;id选择器，class选择器，标签选择器&quot;)</code></li></ul></li><li><p>表单选择器</p><ul><li>使用dom对象的type属性定位</li><li>语法：<code>$(&quot;:type属性值&quot;)</code>。例如如果想要定位所有的text，<code>$(&quot;:text&quot;)</code></li></ul></li><li>过滤器：是一个字符串，用来筛选dom对象的，过滤器需要和选择器一起使用<ul><li>基本选择器<ul><li>选择第一个对象，<code>$(&quot;选择器:first&quot;)</code></li><li>选择最后一个对象，<code>$(&quot;选择器:last&quot;)</code></li><li>选择指定下标的对象，<code>$(&quot;选择器:eq(下标)&quot;)</code></li><li>选择小于指定下标的对象，<code>$(&quot;选择器:lt(下标)&quot;)</code></li><li>选择大于指定下标的对象，<code>$(&quot;选择器:gt(下标)&quot;)</code></li></ul></li><li>表单属性过滤器：根据表单dom对象的状态，过滤dom对象的状态，状态有启用的，不可用的，选中<ul><li>可用的，<code>$(&quot;:text:enabled&quot;)</code></li><li>不可用的，<code>$(&quot;:text:disabled&quot;)</code></li><li>单选或者复选框选中的，<code>$(&quot;:radio:checked&quot;)</code></li><li>下拉列表框的选中，<code>$(&quot;选择器&gt;option:selected&quot;)</code></li></ul></li></ul></li><li><p>函数</p><ul><li><code>val</code>：获取或设置dom对象的value属性值</li><li><code>text</code>：读取或设置标签的文本内容的</li><li><code>attr</code>：读取或设置标签的某个属性值</li><li><code>remove</code>：删除dom和子对象</li><li><code>empty</code>：删除dom的子对象</li><li><code>append</code>：添加dom对象</li><li><code>html</code>：读取或设置标签的文本值，操作的是innerHTML</li><li><code>each</code>：循环<ul><li>普通数组</li><li>json对象</li><li>dom数组</li></ul></li><li><code>each</code>循环的语法<ul><li><code>$.each(循环的对象, function(i, n) &#123;&#125;)</code></li><li><code>jquery对象.each(function(i, n) &#123;&#125;)</code></li></ul></li></ul></li><li><p>jquery处理事件</p><ul><li>绑定事件，<code>jquery对象.事件名称(事件处理函数)</code> — 按钮单击，<code>$(&quot;btn&quot;).click(function()&#123;&#125;)</code></li><li>on绑定事件，<code>jquery对象.on(事件名称，处理函数)</code> — 按钮单击，<code>$(&quot;btn&quot;).on(click, function()&#123;&#125;)</code></li></ul></li><li><p>jquery处理ajax请求：使用的函数 </p><ul><li>核心<code>$.ajax()</code><ul><li>介绍：使用json的参数格式，表示请求的各种参数</li><li>json格式的内容<ul><li><code>url</code>：请求的地址</li><li><code>type</code>：请求的方式，get或post，默认是get</li><li><code>data</code>：请求的参数，使用json格式比较多</li><li><code>dataType</code>：期望服务器端返回的数据格式，可以xml，html，json等</li><li><code>aysnc</code>：布尔值，默认是true，异步的请求方式</li><li><code>success</code>：指定一个函数，当服务器端返回数据时，自动执行这个函数</li><li><code>error</code>：指定一个函数，当错误时执行这个函数</li><li><code>contentType</code>：数据格式，可以不写</li></ul></li></ul></li><li><code>$.post</code>：使用post方式发送请求<ul><li><code>$.post(请求的服务器端地址， 请求的参数， 处理函数， 数据格式json)</code></li></ul></li><li><code>$.get</code>：使用get方式发送请求<ul><li><code>$.get(请求的服务器端地址， 请求的参数， 处理函数， 数据格式json)</code></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX小结</title>
    <link href="/2021/03/28/AJAX%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/03/28/AJAX%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><h4 id="1-Ajax概念：异步的javascript和json"><a href="#1-Ajax概念：异步的javascript和json" class="headerlink" title="1.Ajax概念：异步的javascript和json"></a>1.Ajax概念：异步的javascript和json</h4><h4 id="2-核心对象XMLHttpRequest"><a href="#2-核心对象XMLHttpRequest" class="headerlink" title="2.核心对象XMLHttpRequest"></a>2.核心对象XMLHttpRequest</h4><ul><li>使用步骤<ol><li>创建异步对象<code>var xmlHttp = new XMLHttpRequest()</code></li><li>绑定事件<code>xmlHttp.onreadystatechange = function() &#123; 获取服务器端返回的数据，更新dom&#125;</code></li><li>初始化请求参数<code>xmlHttp.open(get, url, true)</code></li><li>发送请求<code>xmlHttp.send()</code></li></ol></li><li>属性<ol><li><code>readyState</code>：ajax请求过程中的状态变化。<code>4</code>：表示从服务器返回数据，并处理完成</li><li><code>status</code>：网络通信的状态。<code>200</code>：通信成功，请求成功；<code>404</code>：资源没有找到</li></ol></li><li>异步和同步<ul><li>异步：<code>open(get, url, true)</code>，在send之后执行其他的代码，可以同时执行多个异步请求</li><li>同步：<code>open(get, url, false)</code>，一次只能执行一个异步请求，必须请求处理完成后，才能执行其他的请求处理</li></ul></li></ul><h4 id="3-json的使用"><a href="#3-json的使用" class="headerlink" title="3.json的使用"></a>3.json的使用</h4><ul><li><p>json的优点</p><ul><li>json格式好理解</li><li>json格式数据在多种语言中，比较容易处理。使用java，javascript读写json格式的数据比较容易</li><li>json格式数据占用的空间小，在网络中传输快，用户的体验好。</li></ul></li><li><p>java中的json工具库</p><ul><li><p>gson（google）</p></li><li><p>fastjson：速度快，不是最符合json处理规范的</p></li><li><p>jackson：性能好，规范好</p><pre><code class="hljs javascript">ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-comment">// writeValueAsString:把参数的java对象转为json格式的字符串</span><span class="hljs-built_in">String</span> json = om.writeValueAsString(p);</code></pre></li><li><p>json-lib：性能差，依赖多</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ajax</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC开发规则</title>
    <link href="/2021/03/26/MVC%E5%BC%80%E5%8F%91%E8%A7%84%E5%88%99/"/>
    <url>/2021/03/26/MVC%E5%BC%80%E5%8F%91%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><ol><li>MVC开发规则制定了互联网通信开发过程中必须出现的角色有哪些</li><li>MVC开发规则制定了互联网通信开发过程中必须出现的角色所担负的职责</li><li>MVC开发规则制定了互联网通信开发过程中必须出现的角色的出场顺序</li></ol><h4 id="二、角色"><a href="#二、角色" class="headerlink" title="二、角色"></a>二、角色</h4><ul><li>DAO对象：DAO对象提供某张表文件的操作细节，降低对表文件的操作难度。避免反复开发表文件操作的代码，提高代码的复用性</li><li>Service对象：服务对象，提供【业务】的具体解决方案。service对象一个方法指定一个业务的解决方案，避免业务开发重复性开发行为，提供复用性。网站每一个业务都有一个独立标准解决方案</li></ul><h4 id="三、业务"><a href="#三、业务" class="headerlink" title="三、业务"></a>三、业务</h4><p>​    浏览器向Http服务器发送请求</p><p>​    用户向网站发送请求</p><p>​    <strong>举例: </strong>张三用户发送请求，要求在服务端实现将张三账户3000元转给李四账户</p><p>​    业务处理方案：</p><ol><li>判断”张三“是否是当前系统中用户</li><li>判断“李四”是否是当前系统中用户</li><li>读取“张三账户余额”，判断余额是否充足</li><li>读取“李四账户余额”，背账</li><li>更新“张三账户余额 - 3000”</li><li>更新“李四账户余额 + 3000”</li></ol><h4 id="四、业务特征"><a href="#四、业务特征" class="headerlink" title="四、业务特征"></a>四、业务特征</h4><ol><li>真实业务场景中，一个业务往往包含多个分支任务，因此解决业务开发工作量往往比较巨大。</li><li>真实业务场景中，只有所有分支任务都能顺利成功解决，才可以认为当前业务处理成功。</li></ol><h4 id="五、MVC开发规则-—-互联网通信开发过程中必须出现角色有哪些"><a href="#五、MVC开发规则-—-互联网通信开发过程中必须出现角色有哪些" class="headerlink" title="五、MVC开发规则 — 互联网通信开发过程中必须出现角色有哪些"></a>五、MVC开发规则 — 互联网通信开发过程中必须出现角色有哪些</h4><p>一次互联网开发过程，必须出现角色有三个：</p><ul><li>controller object：控制层对象（Servlet对象）</li><li>model object：业务模型对象（Service对象）</li><li>view object：视图层对象（jsp or HttpServletResponse）</li></ul><h4 id="六、MVC开发规则-—-互联网通信开发过程中必须出现角色负担的职责"><a href="#六、MVC开发规则-—-互联网通信开发过程中必须出现角色负担的职责" class="headerlink" title="六、MVC开发规则 — 互联网通信开发过程中必须出现角色负担的职责"></a>六、MVC开发规则 — 互联网通信开发过程中必须出现角色负担的职责</h4><ul><li><p><strong>C（servlet对象）</strong></p><ol><li>【可以】调用【请求对象】读取【请求包】参数信息</li><li>【必须】调用【Service对象】处理业务</li><li>【必须】调用【视图层对象】将结果写入到响应体</li></ol></li><li><p><strong>M（service对象）</strong></p><ol><li>处理业务中所有分支任务</li><li>根据分支任务执行情况判断业务是否处理成功</li><li>必须通过return将处理结果返回给【控制层对象】</li></ol></li><li><p><strong>V（jsp / HttpServletResponse)</strong></p><ol><li>禁止参与业务处理</li><li>唯一的任务是将处理结果写入到响应体中</li></ol></li></ul><h4 id="七、互联网通信开发过程中必须出现角色的出场顺序"><a href="#七、互联网通信开发过程中必须出现角色的出场顺序" class="headerlink" title="七、互联网通信开发过程中必须出现角色的出场顺序"></a>七、互联网通信开发过程中必须出现角色的出场顺序</h4><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210326225823.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EL表达式</title>
    <link href="/2021/03/26/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/03/26/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="一、EL表达式"><a href="#一、EL表达式" class="headerlink" title="一、EL表达式"></a>一、EL表达式</h4><ul><li>命令格式：<code>$&#123;作用域对象别名.共享数据&#125;</code></li><li>命令作用：<ul><li>EL表达式是EL工具包提供的一种特殊的命令格式【表达式命令格式】</li><li>EL表达式在JSP文件上使用</li><li>负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体</li></ul></li></ul><h4 id="二、EL表达式-—-作用域对象别名"><a href="#二、EL表达式-—-作用域对象别名" class="headerlink" title="二、EL表达式 — 作用域对象别名"></a>二、EL表达式 — 作用域对象别名</h4><ul><li><p>JSP文件可以使用的作用域对象</p><ul><li><code>ServletContext</code> — <code>application</code>：全局作用域对象</li><li><code>HttpSession</code> — <code>session</code>：会话作用域对象</li><li><code>HttpServletRequest</code> — <code>request</code>：请求作用域对象</li><li><code>PageContext</code> — <code>pageContext</code>：当前页作用域对象。这是JSP文件独有的作用域对象，Servlet中不存在。在当前页作用域对象存放的共享数据仅能在当前JSP文件中使用，不能共享给其他Servlet或者其他JSP文件。真实开发过程中，主要用于JSTL标签与JSP文件之间数据共享（<code>JSTL --&gt; pageContext --&gt; JSP</code>）</li></ul></li><li><p>EL表达式提供作用域对象别名</p><p>|     JSP     |            EL表达式            |<br>| :————-: | :——————————————: |<br>| application | ${applicationScope.共享数据名} |<br>|   session   |   ${sessionScope.共享数据名}   |<br>|   request   |   ${requestScope.共享数据名}   |<br>| pageContext |    ${pageScope.共享数据名}     |</p></li></ul><h4 id="三、EL表达式将引用对象属性写入到响应体"><a href="#三、EL表达式将引用对象属性写入到响应体" class="headerlink" title="三、EL表达式将引用对象属性写入到响应体"></a>三、EL表达式将引用对象属性写入到响应体</h4><ul><li>命令格式：<code>$&#123;作用域对象别名.共享数据名.属性名&#125;</code></li><li>命令作用：从作用域对象读取指定共享数据关联的引用对象的属性值，并自动将属性的结果写入到响应体</li><li>属性名：一定要与引用类型属性名完全一致（大小写）</li><li>EL表达式没有提供遍历集合的方法，因此无法从作用域对象中读取集合内容输出</li></ul><h4 id="四、EL表达式简化版"><a href="#四、EL表达式简化版" class="headerlink" title="四、EL表达式简化版"></a>四、EL表达式简化版</h4><ul><li>命令格式：<code>$&#123;共享数据名&#125;</code></li><li>命令作用：EL表达式允许开发人员开发时省略作用域对象别名</li><li><p>工作原理：EL表达式简化版由于没有指定作用域对象，所以在执行时采用【猜】算法。按照<code>pageContext ---&gt; request ---&gt; session ---&gt; application</code>的顺序依次查找，若没找到，返回<code>null</code></p></li><li><p>存在隐患：容易降低程序执行速度；容易导致数据定位错误</p></li><li>应用场景：设计目的，就是简化从pageContext读取共享数据并输出难度</li><li>EL表达式简化版尽管存在很多隐患，但是在实际开发过程中，开发人员为了节省时间，一般都使用简化版，拒接使用标准版</li></ul><h4 id="五、EL表达式-—-支持运算表达式"><a href="#五、EL表达式-—-支持运算表达式" class="headerlink" title="五、EL表达式 — 支持运算表达式"></a>五、EL表达式 — 支持运算表达式</h4><ul><li><p>前提：在JSP文件中，有时需要将读取的共享数据进行一番运算之后，将运算结果写入到响应体</p></li><li><p>运算表达式：</p><ul><li>数学运算</li><li><p>关系运算：<code>&gt;(gt)</code>、 <code>&gt;=(ge)</code> 、 <code>==(eq)</code>、  <code>&lt;(lt)</code>、  <code>&lt;=(le)</code>、  <code>!=(!=)</code></p></li><li><p>逻辑运算：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></p></li></ul></li></ul><h4 id="六、EL表达式提供内置对象"><a href="#六、EL表达式提供内置对象" class="headerlink" title="六、EL表达式提供内置对象"></a>六、EL表达式提供内置对象</h4><ol><li><p>命令格式：<code>$&#123;param.请求参数名&#125;</code></p><p>命令作用：通过请求对象读取当前请求包中的请求参数内容，并将请求参数内容写入到响应体</p><p>代替命令：<code>request.getParameter(请求参数名);</code></p></li><li><p>命令格式：<code>$&#123;paramValues.请求参数名[下标]&#125;</code></p><p>命令作用：如果浏览器发送的请求参数是[一个请求参数关联多个值]，此时可以通过paraValues读取请求参数下指定位置的值，并写入到响应体</p><p>代替命令：<code>request.getParameterValues(请求参数名);</code></p></li></ol><h4 id="七、EL表达式常见异常"><a href="#七、EL表达式常见异常" class="headerlink" title="七、EL表达式常见异常"></a>七、EL表达式常见异常</h4><ul><li><code>javax.el.PropertyNotFoundException</code>：在对象中没有找到指定属性</li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP小结</title>
    <link href="/2021/03/26/JSP%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/03/26/JSP%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>JSP文件的作用：代替响应对象，将Servlet中doGet/doPost的执行结果写入到响应体。</p><h3 id="Servlet与JSP"><a href="#Servlet与JSP" class="headerlink" title="Servlet与JSP"></a>Servlet与JSP</h3><h4 id="一、Servlet与JSP分工"><a href="#一、Servlet与JSP分工" class="headerlink" title="一、Servlet与JSP分工"></a>一、Servlet与JSP分工</h4><ul><li>Servlet：负责处理业务并得到处理结果（大厨）</li><li>JSP：不负责业务处理，主要任务将Servlet中处理结果写入到响应体（传菜员）</li></ul><h4 id="二、Servlet与JSP之间调用关系"><a href="#二、Servlet与JSP之间调用关系" class="headerlink" title="二、Servlet与JSP之间调用关系"></a>二、Servlet与JSP之间调用关系</h4><p>​    Serlvet工作完毕后，一般通过<strong>请求转发方式</strong>向Tomcat申请调用JSP</p><h4 id="三、Servlet与JSP之间如何实现数据共享"><a href="#三、Servlet与JSP之间如何实现数据共享" class="headerlink" title="三、Servlet与JSP之间如何实现数据共享"></a>三、Servlet与JSP之间如何实现数据共享</h4><ul><li>Servlet将处理结果添加到【请求作用域对象】</li><li>JSP文件在运行时从【请求作用域对象】得到处理结果</li></ul><hr><h3 id="JSP文件运行原理"><a href="#JSP文件运行原理" class="headerlink" title="JSP文件运行原理"></a>JSP文件运行原理</h3><h4 id="一、Http服务器调用JSP文件步骤"><a href="#一、Http服务器调用JSP文件步骤" class="headerlink" title="一、Http服务器调用JSP文件步骤"></a>一、Http服务器调用JSP文件步骤</h4><ol><li>Http服务器将JSP文件内容【编辑】为一个Servlet接口实现类（.java）</li><li>Http服务器将Servlet接口实现类【编译】为class文件（.class）</li><li>Http服务器负责创建这个class的实例对象，这个实例对象就是Servlet实例对象</li><li>Http服务器通过Servlet实例对象调用jsp_service方法，将jsp文件内容写入到响应体</li></ol><h4 id="二、Http服务器【编辑】与【编译】JSP文件位置"><a href="#二、Http服务器【编辑】与【编译】JSP文件位置" class="headerlink" title="二、Http服务器【编辑】与【编译】JSP文件位置"></a>二、Http服务器【编辑】与【编译】JSP文件位置</h4><p>​    在【work】目录下</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet规范</title>
    <link href="/2021/03/21/Servlet%E8%A7%84%E8%8C%83/"/>
    <url>/2021/03/21/Servlet%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h3 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h3><h4 id="一、Servlet规范介绍："><a href="#一、Servlet规范介绍：" class="headerlink" title="一、Servlet规范介绍："></a>一、Servlet规范介绍：</h4><ul><li>servlet规范来自于JAVAEE规范中的一种</li><li>作用：<ul><li>在Servlet规范中，指定【动态资源文件】开发步骤</li><li>在Servlet规范中，指定Http服务器调用动态资源文件规则</li><li>在Servlet规范中，指定Http服务器管理动态资源文件实例对象规则</li></ul></li></ul><h4 id="二、Servlet接口实现类："><a href="#二、Servlet接口实现类：" class="headerlink" title="二、Servlet接口实现类："></a>二、Servlet接口实现类：</h4><ul><li>Servlet接口是来自于Servlet规范下的一个接口，这个接口存在于Http服务器所提供的jar包中。</li><li>Tomcat服务器下lib文件有一个servlet-api.jar存放Servlet接口（javax.servlet.Servlet接口）。</li><li>Servlet规范中的认为，Http服务器能调用的【动态资源文件】必须是一个Servlet接口实现类。</li></ul><h4 id="三、Servlet接口实现类开发步骤"><a href="#三、Servlet接口实现类开发步骤" class="headerlink" title="三、Servlet接口实现类开发步骤"></a>三、Servlet接口实现类开发步骤</h4><ul><li><p>第一步：创建一个Java类继承于HttpServlet父类，使之成为一个Servlet接口实现类</p></li><li><p>第二步：重写HttpServlet父类中的两个方法。<code>doGet</code>或者<code>doPost</code></p></li><li><p>第三步：将Servlet接口实现类信息【注册】到Tomcat服务器</p><p>【网站】—-&gt;【Web】—-&gt;【WEB-INF】—-&gt; web.xml</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将Servlet接口实现类类路径地址交个Tomcat--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <span class="hljs-comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span> <span class="hljs-comment">&lt;!--声明servlet接口实现类类路径--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>Tomcat  String mm = &quot;com.bjpowernode.controller.OneServlet&quot;<span class="hljs-comment">&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/one<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <span class="hljs-comment">&lt;!--设置简短请求别名，别名在书写时必须以&quot;/&quot;为开头--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>如果现在浏览器向Tomcat索要OneServlet时地址http://localhost:8080/myWeb/one</code></pre></li></ul><h4 id="四、Servlet对象生命周期："><a href="#四、Servlet对象生命周期：" class="headerlink" title="四、Servlet对象生命周期："></a>四、Servlet对象生命周期：</h4><ul><li><p>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器负责创建。开发人员不能手动创建Servlet接口实现类的实例对象。</p></li><li><p>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时，自动创建这个Servlet接口实现类的实例对象。</p><p>在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <span class="hljs-comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span> <span class="hljs-comment">&lt;!--填写一个大于0的整数即可，默认值为0--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre></li><li><p>在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象</p></li><li><p>在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁</p></li></ul><h4 id="五、HttpServletResponse接口"><a href="#五、HttpServletResponse接口" class="headerlink" title="五、HttpServletResponse接口"></a>五、HttpServletResponse接口</h4><ul><li>介绍：<ul><li>HttpServletResponse接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar</li><li>HttpServletResponse接口实现类由Http服务器负责提供</li><li>HttpServletResponse接口负责将<code>doGet/doPost</code>方法执行结果写入到【响应体】交给浏览器</li><li>开发人员习惯于将HttpServletResponse接口修饰的对象称为【响应对象】</li></ul></li><li>主要功能：<ul><li>将执行结果以二进制形式写入到【响应体】</li><li>设置响应头中<code>content-type</code>属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</li><li>设置响应头中【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求</li></ul></li></ul><h4 id="六、-HttpServletRequest接口"><a href="#六、-HttpServletRequest接口" class="headerlink" title="六、 HttpServletRequest接口"></a>六、 HttpServletRequest接口</h4><ul><li>介绍：<ul><li>HttpServletRequest接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar</li><li>HttpServletRequest接口实现类由Http服务器负责提供</li><li>HttpServletRequest接口负责在<code>doGet/doPost</code>方法运行时读取Http请求协议包中信息</li><li>开发人员习惯于将HttpServletRequest接口修饰的对象称为【请求对象】</li></ul></li><li>作用：<ul><li>可以读取Http请求协议包中【请求行】信息</li><li>可以读取保存在Http请求协议包中【请求头】或者【请求体】中请求参数信息</li><li>可以代替浏览器向Http服务器申请资源文件调用</li></ul></li></ul><h4 id="七、请求对象和响应对象生命周期"><a href="#七、请求对象和响应对象生命周期" class="headerlink" title="七、请求对象和响应对象生命周期"></a>七、请求对象和响应对象生命周期</h4><ul><li>在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】。</li><li>在Http服务器调用<code>doGet/doPost</code>方法时，负责将【请求对象】和【响应对象】作为实参传递到方，确保<code>doGet/doPost</code>正确执行。</li><li>在Http服务器准备推送Http相应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】销毁。</li></ul><p>【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中</p><p>【请求对象】和【响应对象】相当于用户在服务端的代言人</p><h4 id="八、欢迎资源文件"><a href="#八、欢迎资源文件" class="headerlink" title="八、欢迎资源文件"></a>八、欢迎资源文件</h4><ul><li><p>前提：用户可以记住网站名，但是不会记住网站资源文件名</p></li><li><p>默认欢迎资源文件：用户发送了一个针对某个网站的【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件</p><ul><li>正常请求：<code>http://localhost:8080/myWeb/index.html</code></li><li>默认请求：<code>http://localhost:8080/myWeb/</code></li></ul></li><li><p>Tomcat对于默认欢迎资源文件定位规则</p><ul><li><p>规则位置：Tomcat安装位置/conf/web.xml</p></li><li><p>规则命令：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span></code></pre></li></ul></li><li><p>设置当前网站的默认欢迎资源文件规则</p><ul><li><p>规则位置：网站/Web/WEB-INF/web.xml</p></li><li><p>规则命令：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>login.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span></code></pre></li><li><p>网站设置自定义默认文件定位规则，此时Tomcat自带定位规则将失效</p></li></ul></li></ul><h4 id="九、Http状态码"><a href="#九、Http状态码" class="headerlink" title="九、Http状态码"></a>九、Http状态码</h4><ul><li><p>介绍：</p><ul><li><p>由三位数字组成的一个符号。</p></li><li><p>Http服务器在推送响应包之前，根据本次请求处理情况，将Http状态码写入到响应包中的【状态行】上</p></li><li><p>如果Http服务器针对本次请求，返回了对应的资源文件。通过Http状态码通知浏览器应该如何处理这个结果。</p><p>如果Http服务器针对本次请求，无法返回对应的资源文件。通过Http状态码向浏览器解释不能提供服务的原因。</p></li><li><p>分类：</p><ul><li><p>组成：100——599 分为5个大类</p></li><li><p><code>1XX</code>：最有特征的是<code>100</code>，通知浏览器本次返回的资源文件，并不是一个独立的资源文件，需要浏览器在接受响应包之后，继续向Http服务器所要依赖的其他资源文件</p></li><li><p><code>2XX</code>：最有特征的是<code>200</code>，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要所要其他关联文件。</p></li><li><p><code>3XX</code>：最有特征的是<code>302</code>，通知浏览器本次返回的不是一个资源文件内容，而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件。</p><p><code>response.sendRedirect(&quot;资源文件地址&quot;)</code>写入到响应头中的<code>location</code>，而这个行为导致Tomcat将<code>302</code>状态码写入到状态行。</p></li><li><p><code>4XX</code>：</p><ul><li><code>404</code>：通知浏览器，由于在服务端没有定位到被访问的资源文件，因此无法提供帮助</li><li><code>405</code>：通知浏览器，在服务端已经定位到北方网的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理。</li></ul></li><li><p><code>5XX</code>：</p><ul><li><code>500</code>：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），这个Servlet可以接受浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败。</li></ul></li></ul></li></ul></li></ul><h4 id="十、多个Servlet之间调用规则："><a href="#十、多个Servlet之间调用规则：" class="headerlink" title="十、多个Servlet之间调用规则："></a>十、多个Servlet之间调用规则：</h4><ul><li>前提条件：浏览器一次只能访问一个Servlet，某些来自于浏览器发送的请求，往往需要服务端中多个Servlet协同处理。</li><li>提高用户使用感受规则：无论本次请求涉及到多少个Servlet，用户只需要【手动】通知浏览器发起一次请求即可。</li><li>多个Servlet之间调用规则：<ul><li>重定向解决方案</li><li>请求转发解决方案</li></ul></li></ul><h4 id="十一、重定向解决方案"><a href="#十一、重定向解决方案" class="headerlink" title="十一、重定向解决方案"></a>十一、重定向解决方案</h4><ul><li><p>工作原理：用户第一次通过【手动方式】通知浏览器访问OneServlet。OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将<code>302</code>状态码写入到状态行。</p><p>在浏览器接收到响应包之后，会读取到<code>302</code>状态。此时浏览器自动根据响应头中location属性地址发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p></li><li><p>实现命令：<code>response.sendRedirect(&quot;请求地址&quot;)</code>，将地址写入到响应包中响应头中location属性</p></li><li><p>特征：</p><ul><li><p>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器（/网站名/资源文件名）</p><p>也可以把其他网站资源文件地址发送给浏览器（<code>http://ip地址:端口号/网站名/资源文件名</code>）</p></li><li><p>请求次数：浏览器至少发送两次请求，但是只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</p></li><li><p>请求方式：重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】。</p></li></ul></li><li><p>缺点：重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间。</p></li></ul><h4 id="十二、请求转发解决方案"><a href="#十二、请求转发解决方案" class="headerlink" title="十二、请求转发解决方案"></a>十二、请求转发解决方案</h4><ul><li><p>原理：用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat在接收到这个请求之后，自动调用TwoServlet来完成剩余任务。</p></li><li><p>实现命令：请求对象代替浏览器向Tomcat发送请求</p><pre><code class="hljs java"><span class="hljs-comment">// 1.通过当前请求对象生成资源文件申请报告对象</span>RequestDispatcher report = resquest.getRequestDispatcher(<span class="hljs-string">&quot;/资源文件名&quot;</span>);<span class="hljs-comment">// 一定要以&quot;/&quot;为开头</span><span class="hljs-comment">// 2.将报告对象发送给Tomcat</span>    report.forward(当前请求对象，当前响应对象);</code></pre></li><li><p>优点：</p><ul><li>无论本次请求涉及到多少个Servlet，用户只需要手动通过浏览器发送一次请求</li><li>Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数，增加处理服务速度。</li></ul></li><li><p>特征：</p><ul><li><p>请求次数：在请求转发过程中，浏览器只发送一次请求</p></li><li><p>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址</p><p><code>request.getRequestDispatcher(&quot;/资源文件名&quot;)</code>    <strong>不要写网站名</strong></p></li><li><p>请求方式：在请求转发过程中，浏览器只发送了一个Http请求协议包。参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接受的请求方式与浏览器发送的请求方式保持一致。</p></li></ul></li></ul><h4 id="十三、多个Servlet之间数据共享实现方案"><a href="#十三、多个Servlet之间数据共享实现方案" class="headerlink" title="十三、多个Servlet之间数据共享实现方案"></a>十三、多个Servlet之间数据共享实现方案</h4><ul><li>数据共享：OneServlet工作完毕后，将产生数据交个TwoServlet来使用</li><li>Servlet规范中提供四种数据共享方案<ul><li><code>ServletContext</code>接口</li><li><code>Cookie</code>接口</li><li><code>HttpSession</code>接口</li><li><code>HttpServletRequest</code>接口</li></ul></li></ul><h4 id="十四、ServletContext接口"><a href="#十四、ServletContext接口" class="headerlink" title="十四、ServletContext接口"></a>十四、ServletContext接口</h4><ul><li><p>介绍：</p><ul><li>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar。在Tomcat中负责提供这个接口实现类</li><li>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享</li><li>开发人员习惯于将ServletContext对象称为【全局作用域对象】</li></ul></li><li><p>工作原理：每一个网站都存在一个全局作用域对象。这个全局作用域对象【相当于】一个Map。在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用。</p></li><li><p>全局作用域对象生命周期：</p><ul><li>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象</li><li>在Http服务器运行期间，一个网站只有一个全局作用域对象</li><li>在Http服务器运行期间，全局作用域对象一直处于存活状态</li><li>在Http服务器准备关闭时，负责将当前网站中全局作用域对象进行销毁处理</li></ul><p><strong>全局作用域对象生命周期贯穿网站整个运行期间</strong></p></li><li><p>实现命令：【同一个网站】OneServlet将数据共享给TwoServlet</p><pre><code class="hljs java">OneServlet &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-comment">// 1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】</span>ServletContext application = request.getServletContext();<span class="hljs-comment">// 2.将数据添加到全局作用域对象作为【共享数据】</span>application.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, 数据);&#125;&#125;TwoServlet &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-comment">// 1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】</span>ServletContext application = request.getServletContext();<span class="hljs-comment">// 2.从全局作用域对象得到指定关键字对应数据</span>Object 数据 = application.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);&#125;&#125;</code></pre></li></ul><h4 id="十五、Cookie"><a href="#十五、Cookie" class="headerlink" title="十五、Cookie"></a>十五、Cookie</h4><ul><li><p>介绍：</p><ul><li>Cookie来自于Servlet规范中一个工具类，存在于Tomcat所提供的servlet-api.jar中</li><li>如果两个Servlet来自于同一个网站，并且为同一个浏览器、用户提供服务，此时借助于Cookie对象进行数据共享</li><li>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量</li></ul></li><li><p>原理：</p><p>用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关的数据。OneServlet工作完毕后，【将Cookie写入到响应头】交还给当前浏览器。</p><p>浏览器收到响应协议包之后，将cookie存储在浏览器的缓存一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时，【浏览器需要无条件的将myWeb网站之前推送过来的cookie，写入到请求头】发送过去。</p><p>此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据</p></li><li><p>实现命令：同一个网站 OneServlet 与 TwoServlet 借助于Cookie实现数据共享</p><pre><code class="hljs java">OneServlet &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;        <span class="hljs-comment">// 1.创建一个cookie对象，保存共享数据（当前用户数据）</span>        Cookie card = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">        cookie相当于一个map</span><span class="hljs-comment">        一个cookie中只能存放一个键值对</span><span class="hljs-comment">        这个键值对的key与value只能是String</span><span class="hljs-comment">        键值对中key不能是中文</span><span class="hljs-comment">        */</span>        <span class="hljs-comment">// 2.将cookie写入到响应头，交给浏览器</span>        response.addCookie(card);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">浏览器/用户&lt;----------响应包 【200】</span><span class="hljs-comment">        【cookie: key1=abc】</span><span class="hljs-comment">【】</span><span class="hljs-comment">【处理结果】</span><span class="hljs-comment"></span><span class="hljs-comment">浏览器向myWeb网站发送请求访问TwoServlet ----&gt; 请求包【url:/myWeb/two method:get】</span><span class="hljs-comment">   【</span><span class="hljs-comment">   请求参数:xxxx</span><span class="hljs-comment">   Cookie  key1=abc</span><span class="hljs-comment">   】</span><span class="hljs-comment">   【】</span><span class="hljs-comment">   【】</span><span class="hljs-comment">*/</span>TwoServlet&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;        <span class="hljs-comment">// 1.调用请求对象从请求头得到浏览器返回的Cookie</span>        Cookie[] cookieArray = request.getCookies();        <span class="hljs-comment">// 2.循环遍历数据得到每一个cookie的key与value</span>        <span class="hljs-keyword">for</span> (Cookie card : cookieArray) &#123;            String key = card.getName();<span class="hljs-comment">// 读取key  &quot;key1&quot;</span>            String value = card.getValue();<span class="hljs-comment">// 读取value &quot;abc&quot;</span>            提供较好的服务。。。        &#125;    &#125; &#125;</code></pre></li><li><p>Cookie销毁时机：</p><ul><li>在默认情况下，Cookie对象存放在浏览器的缓存中，因此只要浏览器关闭，Cookie对象就被销毁掉</li><li>在手动设置情况下，可以要求浏览器将接受的Cookie存放在客户端计算机上的硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器或关闭客户端计算，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除。</li><li><code>cookie.setMaxAge(60);   // cookie在硬盘上存活1分钟</code></li></ul></li></ul><h4 id="十六、HttpSession接口"><a href="#十六、HttpSession接口" class="headerlink" title="十六、HttpSession接口"></a>十六、HttpSession接口</h4><ul><li><p>介绍：</p><ul><li>HttpSession接口来自于Servlet规范下的一个接口。存在于Tomcat中servlet-api.jar。其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar</li><li>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享。</li><li>开发人员习惯于将HttpSession接口修饰对象称为【会话作用域对象】</li></ul></li><li><p>HttpSession与Cookie区别：【面试题】</p><ul><li>存储位置：一个在天上，一个在地下<ul><li>Cookie：存放在客户端计算机（浏览器内存/硬盘）</li><li>HttpSession：存放在服务端计算机内存</li></ul></li><li>数据类型：<ul><li>Cookie：存储的共享数据类型只能是String。</li><li>HttpSession：可以存储任意类型的共享数据Object</li></ul></li><li>数据数量：<ul><li>Cookie：一个Cookie对象只能存储一个共享数据</li><li>HttpSession：使用map集合存储共享数据，所以可以存储任意数量共享数据</li></ul></li><li>参照物：<ul><li>Cookie：相当于客户端在服务端的【会员卡】</li><li>HttpSession：相当于客户在服务端的【私人保险柜】</li></ul></li></ul></li><li><p>命令实现：同一个网站下OneServlet将数据传递给TwoServlet</p><pre><code class="hljs java">OneServlet &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;        <span class="hljs-comment">// 1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span>        HttpSession session = request.getSession();        <span class="hljs-comment">// 2.将数据添加到用户私人储物柜</span>        session.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, 共享数据);    &#125;&#125;<span class="hljs-comment">// 浏览器访问/myWeb中TwoServlet</span>TwoServlet &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;        <span class="hljs-comment">// 1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span>        HttpSession session = request.getSession();        <span class="hljs-comment">// 2.从会话作用域对象得到OneServlet提供的共享数据</span>        Object 共享数据 = session.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);    &#125;&#125;</code></pre></li><li><p>Http服务器如何将用户与HttpSession关联起来：Cookie</p></li><li><p>getSession() 与 getSession(false)</p><ul><li><code>getSession()</code>：如果当前用户在服务端已经拥有了自己的私人储物柜，要求Tomcat将这个私人储物柜进行返回；如果当前用户在服务端尚未拥有自己的私人储物柜，要求tomcat为当前用户创建一个全新的私人储物柜。</li><li><code>getSession(false)</code>：如果当前用户在服务端已经拥有了自己的私人储物柜，要求tomcat将这个私人储物柜进行返回；如果当前用户在服务端尚未拥有自己的私人储物柜，此时Tomcat将返回<code>null</code>。</li></ul></li><li><p>HttpSession销毁时机</p><ul><li>用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中。</li><li>在浏览器关闭时，意味着用户与它的HttpSession关系被切断。</li><li>由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会导致Tomcat将浏览器关联的HttpSession进行销毁。</li><li>为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】。这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟。此时Tomcat认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁掉这个HttpSession。</li></ul></li><li><p>HttpSession空闲时间手动设置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前网站/web/WEB-INF/web.xml--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-comment">&lt;!--当前网站中每一个session最大空闲时间5分钟--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre></li></ul><h4 id="十七、HttpServletRequest接口实现数据共享"><a href="#十七、HttpServletRequest接口实现数据共享" class="headerlink" title="十七、HttpServletRequest接口实现数据共享"></a>十七、HttpServletRequest接口实现数据共享</h4><ul><li><p>介绍：</p><ul><li>在同一个网站中，如果两个servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。 而一个请求协议包只对应一个请求对象，因此servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个Servlet之间实现数据共享。</li><li>在请求对象实现Servlet之间数据共享功能时，开发人员将请求对象称为【请求作用域对象】。</li></ul></li><li><p>实现命令：OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</p><pre><code class="hljs java">OneServlet &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;       <span class="hljs-comment">// 1.将数据添加到【请求作用域对象】中attribute属性</span>        request.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, 数据);<span class="hljs-comment">// 数据类型可以任意类型Object</span>        <span class="hljs-comment">// 2.向Tomcat申请调用TwoServlet</span>        request.getRequestDispatcher(<span class="hljs-string">&quot;/two&quot;</span>).forward(request, response);    &#125;&#125;TwoServlet &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;    <span class="hljs-comment">// 从当前请求对象得到OneServlet写入到共享数据</span>        Object 数据 = request.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);    &#125;&#125;</code></pre></li></ul><h4 id="十八、Servlet规范扩展-——-监听器接口"><a href="#十八、Servlet规范扩展-——-监听器接口" class="headerlink" title="十八、Servlet规范扩展 —— 监听器接口"></a>十八、Servlet规范扩展 —— 监听器接口</h4><ul><li>介绍：<ul><li>一组来自于Servlet规范下的接口，共有8个接口。存在于Tomcat所提供的servlet-api.jar包</li><li>监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类</li><li>监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】</li></ul></li><li><p>作用域对象：</p><ul><li>在Servlet规范中，认为在服务端内存中，可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</li><li>Servlet规范下的作用域对象：<ul><li><code>ServletContext</code>：全局作用域对象</li><li><code>HttpSession</code>：会话作用域对象</li><li><code>HttpServletRequest</code>：请求作用域对象</li></ul></li></ul></li><li><p>将挺起接口实现类开发规范：三步</p><ul><li>根据监听的实际情况，选择对应监听器接口进行实现</li><li>重写监听器接口声明【监听事件处理方法】</li><li>在web.xml文件将监听器接口实现类注册到Http服务器</li></ul></li><li><p><code>ServletContextListener</code>接口：</p><ul><li>作用：通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻</li><li>监听事件处理方法：<ul><li><code>public void contextInitlized()</code>：在全局作用域对象被Http服务器初始化时被调用</li><li><code>public void contextDestory()</code>：在全局作用域对象被Http服务器销毁时触发调用</li></ul></li></ul></li><li><p><code>ServletContextAttributeListener</code>接口：</p><ul><li>作用：通过这个接口合法的检测全局作用域对象中的共享数据的变化时刻</li><li>监听事件处理方法：<ul><li><code>public void contextAdd()</code>：在全局作用域对象添加共享数据时</li><li><code>public void contextReplaced()</code>：在全局作用域对象更新共享数据时</li><li><code>public void contextRemove()</code>：在全局作用域对象删除共享数据时</li></ul></li></ul></li><li>全局作用域对象共享数据变化时刻</li></ul><h4 id="十九、Servlet规范扩展——Filter接口（过滤器接口）"><a href="#十九、Servlet规范扩展——Filter接口（过滤器接口）" class="headerlink" title="十九、Servlet规范扩展——Filter接口（过滤器接口）"></a>十九、Servlet规范扩展——Filter接口（过滤器接口）</h4><ul><li><p>介绍：</p><ul><li>来自于Servlet规范下的接口，在Tomcat中存在于servlet-api.jar包</li><li>Filter接口实现类由开发人员负责提供，Http服务器不负责提供</li><li>Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截</li></ul></li><li><p>具体作用：</p><ul><li>拦截Http服务器，帮助Http服务器检测当前请求合法性</li><li>拦截Http服务器，对当前请求进行增强操作</li></ul></li><li><p>Filter接口实现类开发步骤：三步</p><ul><li>创建一个Java类实现Filter接口</li><li>重写Filter接口中doFilter方法</li><li>web.xml将过滤器接口实现类注册到Http服务器</li></ul></li><li><p>Filter拦截地址格式：</p><ul><li><p>命令格式：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>oneFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>拦截地址<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></li><li><p>命令作用：拦截地址通知Tomcat在调用何种资源文件之前需要调用OneFilter过滤进行拦截</p></li><li><p>要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截</p><p><code>&lt;url-pattern&gt;/img/test.jpg&lt;/url-pattern&gt;</code></p></li><li><p>要求Tomcat在调用某一个文件夹下所有资源文件之前，来调用OneFilter拦截</p><p><code>&lt;url-pattern&gt;/img/*&lt;/url-pattern&gt;</code></p></li><li><p>要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截</p><p><code>&lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;</code></p></li><li><p>要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截</p><p><code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http网络协议包</title>
    <link href="/2021/03/21/Http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85/"/>
    <url>/2021/03/21/Http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Http网络协议包"><a href="#Http网络协议包" class="headerlink" title="Http网络协议包"></a>Http网络协议包</h3><h4 id="一、网络协议包："><a href="#一、网络协议包：" class="headerlink" title="一、网络协议包："></a>一、网络协议包：</h4><ul><li><p>在网络中传递信息都是以<strong>二进制</strong>形式存在的。</p></li><li><p>接收方<strong>浏览器/服务器</strong>在接收信息后，要做第一件事就是将<strong>二进制数据</strong>进行编译【文字、图片、视频、命令】</p></li><li><p>传递信息数据量往往比较巨大，导致接收方很难在一组连续二进制得到对应数据。</p></li><li><p>网络协议包是一组有规律的二进制数据，在这组数据存在了固定空间，每一个空间专门存放特定信息，这样接受方在接收网络协议包之后就可以到固定空间得到对应信息，网络协议包出现极大降低了接收方对接受二进制数据的编译难度。</p></li></ul><h4 id="二、常见网络协议："><a href="#二、常见网络协议：" class="headerlink" title="二、常见网络协议："></a>二、常见网络协议：</h4><ul><li><p><strong>FTP</strong>网络协议包</p></li><li><p><strong>Http</strong>网络协议包</p></li></ul><h4 id="三、Http网络协议包："><a href="#三、Http网络协议包：" class="headerlink" title="三、Http网络协议包："></a>三、Http网络协议包：</h4><ul><li>在基于<code>B/S</code>结构下互联网通信过程中，所有在网络中传递信息都是保存在<strong>Http</strong>网络协议包</li><li>分类：<ul><li><strong>Http</strong>请求协议包</li><li><strong>Http</strong>相应协议包</li></ul></li></ul><h4 id="四、Http请求协议包与Http响应协议包"><a href="#四、Http请求协议包与Http响应协议包" class="headerlink" title="四、Http请求协议包与Http响应协议包"></a>四、Http请求协议包与Http响应协议包</h4><ul><li><p><strong>Http</strong>请求协议包：</p><p>在浏览器准备发送请求时，负责创建一个<strong>Http</strong>请求协议包，浏览器将请求信息以二进制形式保存在<strong>Http</strong>请求协议包各个空间中，由浏览器负责将<strong>Http</strong>请求协议包推送到指定服务端计算机</p></li><li><p><strong>Http</strong>响应协议包：</p><p><strong>Http</strong>服务器在定位到被访问的资源文件之后，负责创建一个<strong>Http</strong>响应协议包，<strong>Http</strong>服务器将定位文件内容或文件命令，并以二进制形式写入到<strong>Http</strong>响应协议包各个空间中，由<strong>Http</strong>服务器负责将<strong>Http</strong>响应协议包推送回发起请求的浏览器上。</p></li></ul><h4 id="五、Http请求协议包内部空间（重点）"><a href="#五、Http请求协议包内部空间（重点）" class="headerlink" title="五、Http请求协议包内部空间（重点）"></a>五、Http请求协议包内部空间（重点）</h4><ul><li><p>按照自上而下划分，分为4个空间 </p></li><li><p>空间划分</p><ul><li><p>请求行：[</p><p>​                    url：请求地址(<a href="http://192.168.100.2:8080/index.html">http://192.168.100.2:8080/index.html</a>)</p><p>​                    method：请求方式（POST / GET）                </p><p>​                ]</p></li><li><p>请求头：[ 请求参数信息【GET】]</p></li><li><p>空白行：[ 没有任何内容，起到隔离作用 ]</p></li><li><p>请求体：[  请求参数信息【POST】 ]</p></li></ul></li></ul><h4 id="六、Http响应协议包内部结构（重点）"><a href="#六、Http响应协议包内部结构（重点）" class="headerlink" title="六、Http响应协议包内部结构（重点）"></a>六、Http响应协议包内部结构（重点）</h4><ul><li><p>按照自上而下划分，分为4个空间</p></li><li><p>空间划分：</p><ul><li>状态行：[ Http状态码 ]</li><li><p>响应头：[ content-type：指定浏览器采用对应编译器，对响应体二进制数据进行解析]</p></li><li><p>空白行：[ 没有任何内容，起到隔离作用 ]</p></li><li>响应体：[ 可能被访问静态资源文件内容、可能被访问的静态资源文件命令、可能被访问的动态资源文件运行结果，都是以二进制形式]</li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网通信流程图</title>
    <link href="/2021/03/21/%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2021/03/21/%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210314183918.png" alt=""></p><hr><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20210321221222.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记</title>
    <link href="/2021/03/11/JavaScript%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/11/JavaScript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>​    JavaScript包括三块：ECMAScript、DOM、BOM</p><ul><li>ECMAScript是ECMA指定的262标准，是JavaScript核心语法</li><li>DOM编程是通过JavaScript对HTML中的dom节点进行操作，DOM是有规范的，DOM规范是W3C制定的。</li><li>BOM编程是对浏览器本身操作，例如：前进、后退、地址栏、关闭窗口、弹窗等。由于浏览器有不同的厂家制造，所以BOM缺少规范，一般只是有一个默认的行业规范。</li></ul><p>​    JS是一门事件驱动型的编程语言，依靠事件去驱动，然后执行对应的程序。在JS中有很多事件，并且任何事件都会对应一个事件句柄。<strong>【注意：事件和事件句柄的区别是：事件句柄是在事件单词前添加一个<code>on</code>】。</strong>而事件句柄是以HTML标签的属性存在的。</p><h4 id="1-JS中的数据类型"><a href="#1-JS中的数据类型" class="headerlink" title="1. JS中的数据类型"></a>1. JS中的数据类型</h4><ul><li>原始类型：<code>Undefined</code>、<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code></li><li>引用类型：<code>Object</code>以及<code>Object</code>的子类</li><li>ES规范（ESMAScript），在ES6之后，又基于以上的6中类型之外添加了一种新的类型：<code>Symbol</code></li><li>JS中有一个运算符叫做<code>typeof</code>，这个运算符可以在程序的运行阶段动态的获取变量的数据类型。<ul><li>typeof 变量名</li><li>运算结果是以下6个字符串之一，注意字符串都是全部小写：<code>undefined</code>、<code>number</code>、<code>string</code>、<code>boolean</code>、<code>object</code>、<code>function</code></li></ul></li><li>在JS当中比较字符串是否相等使用<code>==</code>完成，没有<code>equals</code></li></ul><h5 id="1-1-Undefined"><a href="#1-1-Undefined" class="headerlink" title="1.1 Undefined"></a>1.1 Undefined</h5><p>​    <code>Undefined</code>类型只有一个值，这个值就是<code>undefined</code>，当一个变量没有手动赋值，系统默认赋值<code>undefined</code>，或者也可以给一个变量手动赋值<code>undefined</code>。</p><h5 id="1-2-Number"><a href="#1-2-Number" class="headerlink" title="1.2 Number"></a>1.2 Number</h5><ul><li>Number类型包括哪些值？（整数、小数、正数、负数、NaN、Infinity都属于Number类型）</li><li>运算结果本来应该是一个数字，最后算完不是一个数字的时候，结果是<code>NaN</code></li><li><p>关于<code>isNaN</code>函数，用法：<code>isNaN(数据)</code>。结果是<code>true</code>表示不是一个数字，结果是<code>false</code>表示是一个数字。</p></li><li><p><code>parseInt()</code>函数：将字符串自动转换为数字，并且取整数位。</p></li><li><code>parseFloat()</code>函数：将字符串自动转换为数字。</li><li><code>Math.ceil()</code>函数（Math是数学类，数学类当中有一个函数叫做<code>ceil()</code>，作用是向上取整）</li></ul><h5 id="1-3-Boolean"><a href="#1-3-Boolean" class="headerlink" title="1.3 Boolean"></a>1.3 Boolean</h5><ul><li>在<code>Boolean</code>类型中有一个函数叫做：<code>Boolean(数据)</code>。作用是将非布尔类型转换成布尔类型，“有”就转换成<code>true</code>，“没有”就转换成<code>false</code>。</li></ul><h5 id="1-3-String"><a href="#1-3-String" class="headerlink" title="1.3 String"></a>1.3 String</h5><ul><li>创建字符串对象的两种方式<ul><li><code>var s = &quot;abc&quot;;</code> <strong>小<code>string</code>（属于原始类型<code>String</code>)。</strong></li><li>使用<code>JS</code>内置的支持类<code>String</code>，<code>var s2 = new String(&quot;abc&quot;);</code>。需要注意：<code>String</code>是一个内置的类，可以直接用，<code>String</code>的父类是<code>Object</code>。<strong>大<code>String</code>（属于<code>Object</code>类型）</strong></li><li>无论大小String，属性和函数都是通用的。</li><li>关于<code>String</code>常用的属性和函数：<ul><li>常用属性：<code>length</code>属性</li><li>常用函数：<code>indexOf</code>、<code>lastIndexOf</code>、<code>replace</code>、<code>substr</code>、<code>substring</code>、<code>toLowerCase</code>、<code>toUpperCase</code>、<code>split</code></li><li>子字符串的两个函数的区别：<code>substr(startIndex, length)</code>和<code>substring(startIndex, endIndex) 注意：不包含endIndex</code></li></ul></li></ul></li></ul><h5 id="1-4-Object"><a href="#1-4-Object" class="headerlink" title="1.4 Object"></a>1.4 Object</h5><ul><li><p><code>prototype</code>属性：作用是给类动态的扩展属性和函数 。</p></li><li><p>在<code>JS</code>中如何定义类，怎么<code>new</code>对象？</p><ul><li>定义类的语法：</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种方式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> 类名(<span class="hljs-params">形参</span>) </span>&#123;&#125;<span class="hljs-comment">// 第二种方式：</span>类名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">形参</span>) </span>&#123;&#125;</code></pre><ul><li>创建对象的语法：</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> 构造方法名(实参);<span class="hljs-comment">// 构造方法和类名一致</span></code></pre></li><li><p>在<code>JS</code>中类的定义和构造函数的定义是放在一起来完成的，<code>JS</code>中的类的定义，同时又是一个构造函数的定义</p></li></ul><h4 id="2-null-NaN-undefined这个三个值有什么区别"><a href="#2-null-NaN-undefined这个三个值有什么区别" class="headerlink" title="2. null NaN undefined这个三个值有什么区别"></a>2. null NaN undefined这个三个值有什么区别</h4><ul><li>数据类型不一致。<ul><li><code>typeof null == &quot;object&quot;</code>、<code>typeof NaN == &quot;number&quot;</code>、<code>typeof undefine == &quot;undefined&quot;</code></li><li><code>null == NaN; // false</code>、<code>null == undefined;  // true</code>、<code>undefined == NaN;  // false</code></li><li><code>==</code>（等同运算符：只判断值是否相等）；<code>===</code>（全等运算符：既判断值是否相等，又判断数据类型是否相等）</li></ul></li></ul><h4 id="3-JS中的常用事件"><a href="#3-JS中的常用事件" class="headerlink" title="3. JS中的常用事件"></a>3. JS中的常用事件</h4><ul><li><code>blur</code>：失去焦点；<code>focus</code>：获得焦点</li><li><code>click</code>：鼠标单击；<code>dblclick</code>：鼠标双击</li><li><code>keydown</code>：键盘按下；<code>keyup</code>：键盘弹起</li><li><code>mousedown</code>：鼠标按下；<code>mouseover</code>：鼠标经过；<code>mousemove</code>：鼠标移动；<code>mouseout</code>：鼠标离开；<code>mouseup</code>：鼠标弹起</li><li><code>reset</code>：表单重置；<code>submit</code>：表单提交</li><li><code>change</code>：下拉列表选中项改变，或文本框内容改变</li><li><code>select</code>：文本被锁定</li><li><code>load</code>：页面加载完毕（整个HTML页面中所有的元素全部加载完毕之后发生）</li></ul><p><strong>回调函数</strong>的特点：自己把这个函数代码写出来了，但是这个函数不是自己负责调用，由其他程序负责调用该函数</p><h4 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4. 正则表达式"></a>4. 正则表达式</h4><p>​    正则表达式（Regular Expression）主要用在字符串格式匹配方面。</p><ul><li>常见的正则表达式符号</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母或数字或下划线或汉字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意的空白符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束</td></tr><tr><td style="text-align:center"><strong>重复</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">重复零次或更多次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">重复一次或更多次</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">重复零次或一次</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">重复n次或更多次</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">重复n到m次</td></tr><tr><td style="text-align:center"><strong>反义</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任意不是空白符的字符</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配任意非数字的字符</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配不是单词开头或结束的位置</td></tr><tr><td style="text-align:center"><sup><a href="#fn_x" id="reffn_x">x</a></sup></td><td style="text-align:center">匹配除了x以外的任意字符</td></tr><tr><td style="text-align:center"><sup><a href="#fn_aeiou" id="reffn_aeiou">aeiou</a></sup></td><td style="text-align:center">匹配除了aeiou这个急字母以外的任意字符</td></tr></tbody></table></div><ul><li>创建正则表达式对象及调用</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种创建方式</span><span class="hljs-keyword">var</span> regExp = <span class="hljs-regexp">/正则表达式/</span>flags;<span class="hljs-comment">// 第二种创建方式：使用内置支持类RegExp</span><span class="hljs-keyword">var</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;正则表达式&quot;</span>, <span class="hljs-string">&quot;flags&quot;</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">g关于flags：</span><span class="hljs-comment">g：全局匹配</span><span class="hljs-comment">i：忽略大小写</span><span class="hljs-comment">m：多行搜索（ES规范制定之后才支持m）。当前面是正则表达式的时候，m不能用。只有前面是普通字符串的时候，m才可以使用</span><span class="hljs-comment"></span><span class="hljs-comment">正则表达式对象的test()方法？</span><span class="hljs-comment">true / false = 正则表达式对象.test(用户填写的字符串)</span><span class="hljs-comment">true ： 字符串格式匹配成功</span><span class="hljs-comment">false： 字符从格式匹配失败</span><span class="hljs-comment">*/</span></code></pre><h4 id="5-总结，有哪些方法可以通过浏览器往服务器发请求？"><a href="#5-总结，有哪些方法可以通过浏览器往服务器发请求？" class="headerlink" title="5. 总结，有哪些方法可以通过浏览器往服务器发请求？"></a>5. 总结，有哪些方法可以通过浏览器往服务器发请求？</h4><ul><li>表单form的提交</li><li>超链接</li><li>document.location</li><li>window.location</li><li>window.open(“url”)</li><li>直接在浏览器地址栏上输入URL，然后回车</li></ul><p>以上所有的请求方式均可以携带数据给服务器，只有通过表单提交的数据才是动态的。</p><h4 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a>6. JSON</h4><ul><li><p><code>JavaScript Object Notation</code>，简称<code>JSON</code>（数据交换格式）。是一种标准的数据交换格式。（目前非常流行，90%以上的系统，系统A与系统B交换数据的话，都是采用JSON）</p></li><li><p><code>JSON</code>是一种标准的轻量级的数据交换格式。特点是：体积小、易解析</p></li><li><p>在实际的开发中有两种数据交换格式，使用最多，其一是<code>JSON</code>，另一个是<code>XML</code></p><p><code>XML</code>体积较大，解析麻烦，但是有其优点是：语法严谨。（通常银行相关的系统之间进行数据交换的话会使用<code>XML</code>)</p></li><li><p>JSON的分类：</p><ol><li>json对象，<code>JSONObject</code>，这种对象的格式为，<code>名称：值</code>，也可以看做是<code>key：value</code>格式。</li><li>json数组，<code>JSONArray</code>，基本格式[{….}, {….}, ….]</li></ol></li><li><p><code>JSON</code>语法格式：</p><pre><code class="hljs json">var jsonObj = &#123;&quot;属性名&quot; : 属性值,&quot;属性名&quot; : 属性值,&quot;属性名&quot; : 属性值,&quot;属性名&quot; : 属性值,...&#125;;</code></pre></li><li><p><code>eval()</code>函数的作用：将字符串当作一段JS代码解释并执行。</p><p>可以使用<code>eval</code>函数，将<code>JSON</code>格式的字符串转换成<code>JSON</code>对象。</p></li><li><p>在JS当中，<code>[]</code>和<code>&#123;&#125;</code>有什么区别？</p><ul><li>java中的数组：<code>int[] arr = &#123;1, 2, 3, 4, 5&#125;;</code></li><li>JS中的数组：<code>var arr = [1, 2, 3, 4, 5];</code></li><li>JSON：<code>var jsonObj = &#123;&quot;email&quot; : &quot;zhangsan@123.com&quot;, &quot;age&quot; : 25&#125;;</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL小结</title>
    <link href="/2021/02/21/MySQL%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/02/21/MySQL%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="SQL语句的分类："><a href="#SQL语句的分类：" class="headerlink" title="SQL语句的分类："></a>SQL语句的分类：</h3><p><strong>DQL（数据库查询语言）:</strong> 查询语句，凡是<code>select</code>语句都是<code>DQL</code>。</p><p><strong>DML（数据操作语言）: </strong> <code>insert delete update</code>，对表当中的数据进行增删改。</p><p><strong>DDL（数据定义语言）: </strong><code>create drop alter</code>，对表结构的增删改。</p><p><strong>TCL（事务控制语言）： </strong><code>commit</code>提交事务，<code>rollback</code>回滚事务。（<code>TCL</code>中的<code>T</code>是<code>Transaction</code>）</p><p><strong>DCL（数据控制语言）： </strong><code>grant</code>授权，<code>revoke</code>撤销权限等。</p><p>增删改查的术语：<strong>CRUD</strong>操作</p><p>Create（增）、Retrieve（检索）、Update（修改）、Delete（删除）</p><hr><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><pre><code class="hljs mysql"># sql语句执行顺序select5..from1..where2..group by3..having4..order by6..limit 7..;</code></pre><h4 id="分组函数：对“某一组”数据进行操作。"><a href="#分组函数：对“某一组”数据进行操作。" class="headerlink" title="分组函数：对“某一组”数据进行操作。"></a>分组函数：对“某一组”数据进行操作。</h4><p>​    <code>sum</code>、<code>count</code>、<code>avg</code>、<code>max</code>、<code>min</code>总共5个，还有另一个名字：多行处理函数，即输入多行，最终输出的结果是1行。</p><p><strong>注意：</strong></p><ul><li>自动忽略<code>null</code>。</li><li><p>分组函数不可直接使用在<code>where</code>子句当中。</p></li><li><p><code>count(*)</code>：不是统计某个字段中数据的个数，而是统计总记录条数（和某个字段无关）；<code>count(comm)</code>：表示统计comm字段中不为NULL的数据总数量。</p></li></ul><hr><h4 id="group-by-和-having"><a href="#group-by-和-having" class="headerlink" title="group by 和 having"></a>group by 和 having</h4><ul><li><code>group by</code>：按照某个字段或者某些字段进行分组。</li><li><code>having</code>：对分组之后的数据进行再次过滤。</li></ul><p><strong>注意：</strong></p><ul><li>分组函数一般都会和group by联合使用。且任何一个分组函数都是在group by语句执行结束之后才会执行。</li><li>当一条语句使用group by时，select后只能出现<strong>参加分组的字段</strong>，以及<strong>分组函数</strong>。</li></ul><hr><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>​    去除重复记录。</p><p><strong>注意： </strong></p><ul><li>distinct只能出现在所有字段的最前面。 </li><li><code>select distinct deptno, job from emp;</code>是后面所有字段联合去重。</li></ul><hr><h4 id="limit-（重点中的重点，分页查询）"><a href="#limit-（重点中的重点，分页查询）" class="headerlink" title="limit （重点中的重点，分页查询）"></a>limit （重点中的重点，分页查询）</h4><ul><li><p>limit是mysql特有的，其他数据库中没有不通用。</p></li><li><p>limit取结果集中的部分数据，这是它的作用。</p></li><li><p>语法机制：</p><pre><code class="hljs mysql">limit startIndex, lengthstartIndex表示起始位置，从0开始，0表示第一条数据。length表示取几个# 直接写一个数字，前面startIndex默认为0</code></pre></li><li><p>limit是sql语句最后执行的一个环节</p></li></ul><hr><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><p>MySQL常用数据类型</p><p>|             类型             |                             描述                             |<br>| :—————————————: | :—————————————————————————————: |<br>|          Char(长度)          |       定长字符串，存储空间大小固定，适合作为主键或外键       |<br>|        Varchar(长度)         |             变长字符串，存储空间等于实际数据空间             |<br>| double(有效数字位数，小数位) |                            数值型                            |<br>| Float(有效数字位数，小数位)  |                            数值型                            |<br>|          Int(长度)           |                             整型                             |<br>|         bigint(长度)         |                            长整型                            |<br>|             Date             |                        日期型 年月日                         |<br>|           DateTime           |                  日期型 年月日 时分秒 毫秒                   |<br>|             time             |                        日期型 时分秒                         |<br>|             BLOB             | Binary Large OBject（二进制大对象, 存储图片、视频等流媒体信息） |<br>|             CLOB             | Character Large OBject（字符大对象，存储较大文本，比如，可以存储4G的字符串） |<br>|          其他……          |                                                              |</p></li></ul><hr><h4 id="约束（Constraint）"><a href="#约束（Constraint）" class="headerlink" title="约束（Constraint）"></a>约束（Constraint）</h4><ul><li>非空约束（not null）：约束的字段不能为NULL</li><li>唯一约束（unique）：约束的字段不能重复</li><li>主键约束（primary key）：约束的字段既不能为NULL，也不能重复（简称PK）</li><li>外键约束（foreign key）：。。。（简称FK）</li><li>检查约束（check）：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持。</li></ul><p><strong>1. 唯一性约束（unique）</strong></p><ul><li>唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL。</li><li>注意：not null约束只有列级约束，没有表级约束。</li></ul><p><strong>2. 主键约束（primary key）</strong></p><ul><li>主键相关术语：主键约束、主键字段、主键值。</li><li>主键值是这行记录在这张表当中的唯一标识。</li></ul><p><strong>3. 外键约束（foreign key）</strong></p><ul><li><code>foreign key(classno) references t_class(cno)</code></li><li>外键值可以为<code>NULL</code></li><li>外键字段不一定是主键，但至少具有<code>unique</code>约束。</li></ul><hr><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li><p>添加索引是给某一个字段，或者某些字段添加索引。</p></li><li><p>最根本的原理是缩小了扫描的范围。索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断地维护。是有维护成本的。比如，表中的数据经常被修改这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p></li><li><p><strong>字段添加索引的条件</strong>：数据量庞大；该字段很少的DML操作；该字段经常出现在where子句中。</p></li><li><p>创建索引：<code>create index 索引名称 on  表名(字段名);</code></p></li><li>删除索引：<code>drop index 索引名称 on  表名;</code></li><li>索引底层采用的数据结构是：B Tree。</li><li><p><strong>实现原理：</strong>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。</p></li><li><p>索引的分类</p><ul><li><p>单一索引：给单个字段添加索引</p></li><li><p>复合索引：给多个字段联合起来添加1个索引</p></li><li><p>主键索引：主键上会自动添加索引</p></li><li><p>唯一索引：有<code>unique</code>约束的字段上会自动添加索引</p><p>。。。</p></li></ul></li><li><p>模糊查询的时候，第一个通配符使用的是<code>%</code>，这个时候索引是失效的。</p></li></ul><hr><h4 id="视图（view"><a href="#视图（view" class="headerlink" title="视图（view)"></a>视图（view)</h4><ul><li>视图就是站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。</li><li>创建视图：<code>create view myview as select empno, ename, from emp;</code></li><li>删除视图：<code>drop view myview;</code></li><li>对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）</li><li>视图的作用：视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。</li></ul><hr><h4 id="表的设计经典设计方案"><a href="#表的设计经典设计方案" class="headerlink" title="表的设计经典设计方案"></a>表的设计经典设计方案</h4><ul><li>多对多？ 三张表，关系表两个外键</li><li>一对多？两张表，多的表加外键</li><li>一对一？主键共享；外键唯一</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂模板</title>
    <link href="/2021/02/06/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/02/06/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法在指数n非常大的时候，时间复杂度会非常高。</p><p>快速幂算法的核心思想就是每一步都把指数分成两半，二相应的底数做平方运算。这样指数会不断变小，从而所需要执行的循环次数也变小。</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<span class="hljs-comment">// a为底数，b为指数，p为模值</span><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p;<span class="hljs-comment">// p=1时，任何数模1都为0</span><span class="hljs-keyword">while</span> (b) &#123;<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)res = (LL)res * a % p;b &gt;&gt;= <span class="hljs-number">1</span>;a = (LL)a * a % p;&#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛选算法——埃式筛法</title>
    <link href="/2020/12/03/%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%83%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    <url>/2020/12/03/%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%83%E5%BC%8F%E7%AD%9B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>埃拉托色尼筛选法，全名Sieve of Eratosthenes，简称埃式筛法。算法基于一项基本性质：任何大于1的自然数，要么本身是质数，要么可以分解为几个质数之积，且这种分解是唯一的。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>质数的倍数一定不是质数。任何大于1的自然数，要么本身是质数，要么可以分解为几个质数之积，且这种分解是唯一的。  </p><p>因此我们以每个质数为始，标记其在数据范围内的所有倍数为合数。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>在遍历以<code>n</code>为范围的数字时，结束边界设为<code>sqrt(n)</code>。</li><li>在以质数<code>i</code>为始筛查时，从<code>i*i</code>开始标记，而不是从<code>i*2</code>开始。因为当<code>i &gt; 2</code>时，<code>i*2</code>肯定已经被素数2给过滤了，避免重复计算。</li></ol><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">boolean</span>[] isPrim = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>];    Arrays.fill(isPrim, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (isPrim[i]) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i*i; j &lt; n; j += i) &#123;                isPrim[j] = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (isPrim[i])count++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><ul><li>时间复杂度：O(nlognlogn)，证明不需要掌握，知道即可</li><li>空间复杂的：O(n)，用来标记是否为质数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>素数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>朴素贝叶斯实现文本数据的分类与分析</title>
    <link href="/2020/11/30/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2020/11/30/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>关于实现朴素贝叶斯算法的原理，<a href="https://www.cnblogs.com/hapjin/articles/8119797.html">参考于此</a>。</p><p>利用朴素贝叶斯算法实现对文本的数据挖掘，主要包括：</p><ol><li>语料库的构建，主要包括利用爬虫收集Web文档等。</li><li>语料库的数据预处理，包括文档建模，如去噪，分词，建立数据字典。</li><li>自行实现朴素贝叶斯，训练文本分类器。</li><li>对测试集的文本进行分类</li><li>对测试集的分类结果利用正确率和召回率进行分析评价。</li></ol><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><ol><li>爬虫技术：</li></ol><p>依赖python requests库：requests可以支持HTTP特性，是python中最常用的http客户端库。  </p><p>从环球网、新浪网、搜狐网等大型门户网站上爬取得到的原始数据如下图所示。文本数据所属类别分别包括：动漫、汽车、娱乐、财经、游戏、健康、历史、军事、运动、科技，共十大类。总体数据量共一百万条。</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201130232028.png" alt=""></p><ol><li>对爬取到的数据进行分词  </li></ol><p>使用jieba分词库将所有句子分成词组的形式，再通过停用词表过滤过滤掉所有的停用词和字符。得到如下文本数据如下图所示。</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201130232158.png" alt=""></p><ol><li>生成词袋</li></ol><p>再通过使用<code>TF_IDF</code>技术，贝叶斯算法需要保留按照分值排序前40000个词汇，获得经过<code>TF_IDF</code>处理后的词汇表。  </p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201130232356.png" alt=""></p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>对于50w条测试集的测试结果展示：</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201130225901.png" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201130225937.png" style="zoom: 67%;" /></p><h5 id="程序使用数据集以及具体实现代码，点击这里"><a href="#程序使用数据集以及具体实现代码，点击这里" class="headerlink" title="程序使用数据集以及具体实现代码，点击这里"></a>程序使用数据集以及具体实现代码，<a href="https://github.com/Yeefine/DM_DW_Exercise">点击这里</a></h5>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>朴素贝叶斯</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务小结</title>
    <link href="/2020/11/30/%E4%BA%8B%E5%8A%A1%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/11/30/%E4%BA%8B%E5%8A%A1%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="1-事物的基本介绍："><a href="#1-事物的基本介绍：" class="headerlink" title="1. 事物的基本介绍："></a>1. 事物的基本介绍：</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h4><p>​    如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p><h4 id="2-操作："><a href="#2-操作：" class="headerlink" title="2. 操作："></a>2. 操作：</h4><ol><li>开启事务： start transaction;</li><li>回滚： rollback;</li><li>提交： commit;</li></ol><h4 id="3-MySQL数据库中事务默认自动提交"><a href="#3-MySQL数据库中事务默认自动提交" class="headerlink" title="3. MySQL数据库中事务默认自动提交"></a>3. MySQL数据库中事务默认自动提交</h4><ul><li><p>事务提交的两种方式：</p><ul><li>自动提交：<ul><li>mysql就是自动提交的</li><li>一条DML（增删改）语句会自动提交一次事务</li></ul></li><li>手动提交：<ul><li>Oracle数据库默认是手动提交事务</li><li>需要先开启事务，再提交</li></ul></li></ul></li><li><p>修改事务的默认提交方式：</p><ul><li>查看事务的默认提交方式 ：SELECT&ensp;@@autocommit;&emsp;—1&ensp;代表自动提交&emsp;0&ensp;代表手动提交</li><li>修改默认提交方式：set @@autocommit = 0;</li></ul></li></ul><h3 id="2-事务的四大特性（ACID-："><a href="#2-事务的四大特性（ACID-：" class="headerlink" title="2. 事务的四大特性（ACID)："></a>2. 事务的四大特性（ACID)：</h3><p><strong>1. 原子性(Atomicity)：是不可分割的最小操作单位，要么同时成功，要么同时失败。</strong></p><p><strong>2. 一致性(Consistency)：事务操作前后，数据总量不变。</strong></p><p><strong>3. 隔离性(Isolation)：多个事务之间，相互独立。</strong></p><p><strong>4. 持久性(Durability)：当事务提交或回滚后，数据库会持久化的保存数据。</strong></p><h3 id="3-事物的隔离级别（了解）"><a href="#3-事物的隔离级别（了解）" class="headerlink" title="3. 事物的隔离级别（了解）"></a>3. 事物的隔离级别（了解）</h3><ul><li><p>概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p></li><li><p>存在问题：</p><ol><li>脏读：一个事务，读取到另一个事务中没有提交的数据</li><li>不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样</li><li>幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li></ol></li><li><p>隔离级别：</p><ol><li><code>read uncommited</code>：读未提交<ul><li>产生的问题：脏读、不可重复读、幻读</li></ul></li><li><code>read commited</code>：读已提交&emsp;（Oracle）<ul><li>产生的问题：不可重复读、幻读</li></ul></li><li><code>repeatable read</code>：可重复读&emsp;（MySQL默认）<ul><li>产生的问题：幻读</li></ul></li><li><code>serializable</code>：串行化<ul><li>可以解决所有的问题</li></ul></li></ol><ul><li>注意：隔离级别从小到大安全性越来越高，但是效率越来越低</li><li>数据库查询隔离级别：<ul><li><code>select @@tx_isolation;</code></li></ul></li><li>数据库涉资隔离级别：<ul><li><code>set global transaction isolation level 级别字符串;</code></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>范式小结</title>
    <link href="/2020/11/29/%E8%8C%83%E5%BC%8F%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/11/29/%E8%8C%83%E5%BC%8F%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。    </p><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。  </p><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。    </p><h3 id="补充概念："><a href="#补充概念：" class="headerlink" title="补充概念："></a>补充概念：</h3><ol><li><p><strong>函数依赖：</strong>A—&gt;B，如果通过A属性（属性组）的值，可以确定唯一B属性的值，则称B依赖于A。</p><p>例如： 学号—&gt;姓名、（学号，课程名称）—&gt; 分数  </p></li><li><p><strong>完全函数依赖：</strong> A—&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。</p><p>例如：（学号，课程名称）—&gt; 分数</p></li><li><p><strong>部分函数依赖：</strong> A—&gt;B，如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。</p><p>例如：（学号，课程名称）—&gt; 姓名</p></li><li><p><strong>传递函数依赖：</strong> A—&gt;B，B—&gt;C。如果通过A属性（属性值）的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递函数依赖于A。</p><p>例如：学号 —&gt; 系名，系名 —&gt;系主任</p></li><li><p><strong>码：</strong> 如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性值）为该表的码。</p><p>例如：下例的该表中为码为：（学号，课程名称）</p></li></ol><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ol><li><p><strong>第一范式（1NF）</strong>：每一列都是不可分割的原子数据项。</p></li><li><p><strong>第二范式（2NF）</strong>：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）  </p><p><strong>多对多？ 三张表，关系表两个外键</strong></p></li><li><p><strong>第三范式（3NF）</strong>：在2NF基础上，任何非主属性不依赖于其他非主属性（在2NF基础上消除传递依赖）</p><p><strong>一对多？两张表，多的表加外键</strong></p></li></ol><h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><h4 id="1-非范式表-——-gt-1NF"><a href="#1-非范式表-——-gt-1NF" class="headerlink" title="1. 非范式表 ——&gt; 1NF"></a>1. 非范式表 ——&gt; 1NF</h4><p>​    左边的表中<strong>系</strong>这一列被分割为（系名，系主任），因此不满足<code>1NF</code>的要求。</p><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201129224335.png" alt=""></p><p>右表为改进后的表，满足<code>1NF</code>。但同时也存在以下几个问题：    </p><ol><li>存在非常严重的数据冗余（重复）：姓名、系名、系主任</li><li>数据添加存在问题：添加新开设的系和系主任时，数据不合法</li><li>数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。</li></ol><h4 id="2-1NF-——-gt-2NF"><a href="#2-1NF-——-gt-2NF" class="headerlink" title="2. 1NF ——&gt; 2NF"></a>2. 1NF ——&gt; 2NF</h4><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201129234647.png" alt=""></p><p>存在的问题：</p><p>​    <del>存在非常严重的数据冗余（重复）：姓名、系名、系主任</del></p><ol><li>数据添加存在问题：添加新开设的系和系主任时，数据不合法</li><li>数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。</li></ol><h4 id="3-2NF-——-gt-3NF"><a href="#3-2NF-——-gt-3NF" class="headerlink" title="3. 2NF ——&gt; 3NF"></a>3. 2NF ——&gt; 3NF</h4><p><img src="https://raw.githubusercontent.com/Yeefine/picBed/master/20201129235556.png" alt=""></p><p>上述三个问题全部被解决掉了！！</p><h4 id="提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。"><a href="#提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。" class="headerlink" title="提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。"></a>提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</h4>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射案例</title>
    <link href="/2020/11/27/%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B/"/>
    <url>/2020/11/27/%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>需求：写一个“框架，可以帮我们创建任意类的对象，并执行其中任意方法。</li><li>实现：<ul><li>配置文件</li><li>反射</li></ul></li><li>步骤：<ul><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ul></li></ul><p>首先定义配置文件<code>pro.properties</code>：</p><pre><code class="hljs properties"><span class="hljs-attr">className</span>=<span class="hljs-string">com.domain.Student</span><span class="hljs-attr">methodName</span>=<span class="hljs-string">sleep</span></code></pre><p>定义两种测试类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;sleep...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;eat...&quot;</span>);    &#125;&#125;</code></pre><p>定义反射测试类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 1.加载配置文件</span>        <span class="hljs-comment">// 1.1创建Properties对象</span>        Properties pro = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-comment">// 1.2加载配置文件，转换为一个集合</span>        <span class="hljs-comment">// 1.2.1获取class目录下的配置文件</span>        ClassLoader classLoader = ReflectTest.class.getClassLoader();        InputStream is = classLoader.getResourceAsStream(<span class="hljs-string">&quot;pro.properties&quot;</span>);        pro.load(is);        String className = pro.getProperty(<span class="hljs-string">&quot;className&quot;</span>);        String methodName = pro.getProperty(<span class="hljs-string">&quot;methodName&quot;</span>);        Class cls = Class.forName(className);        Object o = cls.getDeclaredConstructor().newInstance();        Method method = cls.getMethod(methodName);        method.invoke(o);    &#125;&#125;</code></pre><p>若想创建<code>Person</code>对象且执行<code>eat()</code>方法，无需修改具体的代码实现部分，仅需修改配置文件<code>pro.properties</code>为：</p><pre><code class="hljs properties"><span class="hljs-attr">className</span>=<span class="hljs-string">com.domain.Person</span><span class="hljs-attr">methodName</span>=<span class="hljs-string">eat</span></code></pre><p>如果所写的系统十分庞大，修改java代码后，需要重新测试，重新编译，重新上线等等。但是配置文件仅仅只是一个物理文件，修改方便，且让程序的扩展性更强。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口的内容小结</title>
    <link href="/2020/10/18/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/10/18/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Java 9+版本中，接口的内容可以有：</p><p><strong>1. 成员变量其实是常量，格式：</strong></p><p>[public]&nbsp; [static]&nbsp; [final]&nbsp; 数据类型&nbsp; 常量名称&nbsp; =&nbsp; 数据值；</p><p><strong>注意：</strong></p><p>&emsp;常量必须进行赋值，而且一旦赋值不能改变。</p><p>&nbsp; &nbsp; 常量名称完全大写，用下划线进行分隔。</p><p><strong>2. 接口中最重要的就是抽象方法，格式：</strong></p><p>[public]&nbsp; [abstract]&nbsp; 返回值类型 方法名称(参数列表);</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; 实现类必须覆盖重写接口所有的抽象方法，除非实现类时抽象类。</p><p><strong>3. 从Java 8开始，接口里允许定义默认方法，格式：</strong></p><p>[public]&nbsp; <strong>default</strong> 返回值类型 方法名称(参数列表) { 方法体 }</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; 默认方法也可以被覆盖重写</p><p><strong>4.从Java 8开始，接口里允许定义静态方法，格式：</strong></p><p>[public] <strong>static</strong> 返回值类型 方法名称(参数列表) { 方法体 }</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; 应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p><p><strong>5.从Java 9开始，接口里允许定义私有方法，格式：</strong></p><p>普通私有方法： private 返回值类型 方法名称(参数列表) { 方法体 }</p><p>静态私有方法： private static 返回值类型 方法名称(参数列表) { 方法体}</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; private的方法只有接口自己才能调用，不能被实现类或别人使用。</p><h4 id="使用接口的时候，需要注意："><a href="#使用接口的时候，需要注意：" class="headerlink" title="使用接口的时候，需要注意："></a>使用接口的时候，需要注意：</h4><ol><li>接口是没有静态代码块或者构造方法的。</li><li>一个类的直接父类是唯一的，但是一个类可以同时实现<strong>多个</strong>接口。</li></ol><p>格式：</p><p>public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {</p><p>&emsp; // 覆盖重写所有抽象方法</p><p>}</p><ol start="3"><li>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</li><li>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</li><li>如果实现类所实现的多个接口当中，存在重复的<strong>默认方法</strong>，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果直接父类当中的方法，和接口当中的<strong>默认方法</strong>产生了冲突，优先用父类当中的方法。</li></ol><h4 id="接口的多继承："><a href="#接口的多继承：" class="headerlink" title="接口的多继承："></a>接口的多继承：</h4><ol><li>类与类之间是<strong>单继承</strong>的。直接父类只有一个。</li><li>类与接口之间是多实现的。一个类可以实现多个接口。</li><li>接口与接口之间是<strong>多继承</strong>的。</li></ol><p><strong>注意事项：</strong></p><ol><li>多个父接口当中的抽象方法如果重复，没关系。</li><li>多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，<strong>【而且带着default关键字】</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>super和this关键字图解</title>
    <link href="/2020/10/16/super%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%BE%E8%A7%A3/"/>
    <url>/2020/10/16/super%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%BE%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20201016161306.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>super</tag>
      
      <tag>this</tag>
      
      <tag>内存图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父子类构造方法的访问特点</title>
    <link href="/2020/10/16/%E7%88%B6%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/"/>
    <url>/2020/10/16/%E7%88%B6%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>在继承关系中，父子类构造方法的访问特点：</p><ol><li>子类构造方法当中有一个默认隐含的 <em>“super()”</em> 调用，所以一定是先调用的父类构造，后执行的子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造。</li><li>super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li></ol><p>总结：</p><p>​    子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fu</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;父类无参构造执行&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;父类有参构造执行&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Zi</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        super();    // 在调用父类无参构造方法</span>        <span class="hljs-keyword">super</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 在调用父类重载的构造方法</span>        System.out.println(<span class="hljs-string">&quot;子类构造方法执行&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        super();  // 错误写法！只有子类构造方法，才能调用父类构造方法。</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Constructor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Zi zi = <span class="hljs-keyword">new</span> Zi();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>构造方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中方法的覆盖重写</title>
    <link href="/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99/"/>
    <url>/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h3 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h3><p>概念：在继承关系中，方法的名称一样，参数列表<strong>也一样</strong>。建议使用覆盖、覆写的叫法，不易混淆。</p><h4 id="重写与重载的区别："><a href="#重写与重载的区别：" class="headerlink" title="重写与重载的区别："></a>重写与重载的区别：</h4><ul><li>重写（Override）：方法的名称一样，参数列表<strong>也一样</strong>。覆盖、覆写。</li><li>重载（Overload）：方法的名称一样，参数列表<strong>不一样</strong>。详情请见<a href="https://yeefine.github.io/2020/07/22/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/">方法重载</a></li></ul><h4 id="方法覆盖重写的注意事项："><a href="#方法覆盖重写的注意事项：" class="headerlink" title="方法覆盖重写的注意事项："></a>方法覆盖重写的注意事项：</h4><ol><li><p>必须保证父子类之间的方法名称相同，参数列表也相同。</p><p>@Override：写在方法前面，用来检测是不是有效的正确覆盖方法。</p><p>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</p></li><li><p>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围。</p><p>小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</p></li><li><p>子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符。</p><p>小扩展提示：public &gt; protected &gt; (default) &gt; private</p><p>备注：（default）不是关键字default，而是什么都不写，留空。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>Override</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中成员变量的访问特点</title>
    <link href="/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/"/>
    <url>/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>当类之间产生了关系后，其中各类中的成员变量，有产生了哪些影响呢？</p><h4 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h4><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。</p><h4 id="成员变量重名时"><a href="#成员变量重名时" class="headerlink" title="成员变量重名时"></a>成员变量重名时</h4><p>创建子类对象时，访问有两种方式：</p><ul><li><p>直接通过子类对象访问成员变量：</p><p>等号左边是谁，就优先用谁，没有则向上找。</p></li><li><p>间接通过成员方法访问成员变量：</p><p>该方法属于谁，就优先用谁，没有则向上找。</p></li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-keyword">int</span> numFu = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">100</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodFu</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(num);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span></span>&#123;    <span class="hljs-keyword">int</span> numZi = <span class="hljs-number">20</span>;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">200</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodZi</span><span class="hljs-params">()</span></span>&#123;        System.out.println(num);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01ExtendsField</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Fu fu = <span class="hljs-keyword">new</span> Fu();        System.out.println(fu.numFu);   <span class="hljs-comment">// 10</span>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);        Zi zi = <span class="hljs-keyword">new</span> Zi();        System.out.println(zi.numFu);   <span class="hljs-comment">// 10</span>        System.out.println(zi.numZi);   <span class="hljs-comment">// 20</span>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);        <span class="hljs-comment">// 等号左边是谁，就优先用谁</span>        System.out.println(zi.num);     <span class="hljs-comment">// 优先子类， 200</span><span class="hljs-comment">//        System.out.println(zi.abc);   // 到处都没有，编译报错！</span>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);        <span class="hljs-comment">// 这个方法是子类的，优先用子类的，没有再向上找</span>        zi.methodZi();  <span class="hljs-comment">// 200</span>        <span class="hljs-comment">// 这个方法是在父类中定义的，</span>        zi.methodFu();  <span class="hljs-comment">// 100</span>    &#125;&#125;</code></pre><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要用<code>super</code>关键字，修饰父类成员变量，类似于之前学过的<code>this</code>。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-comment">// Zi中的成员变量</span>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">6</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 访问父类中的num</span>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-keyword">super</span>.num);        <span class="hljs-comment">// 访问子类中的num</span>        System.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-keyword">this</span>.num);    &#125;&#125;</code></pre><p>小贴士：Fu类中的成员变量是<strong>非私有的</strong>，子类中可以直接访问。若Fu类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>成员变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K-近邻算法</title>
    <link href="/2020/10/09/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2020/10/09/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>​        简单地说，k-近邻算法采用测量不同特征值之间的距离方法进行分类。</p><ul><li><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>存在一个样本数据集合，也称为训练样本集，并且样本集中每个数据都存在标签。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p></li><li><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>精度高、对异常值不敏感、无数据输入假定。</p></li><li><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>计算复杂度高、空间复杂度高。</p></li><li><h3 id="适用数据范围："><a href="#适用数据范围：" class="headerlink" title="适用数据范围："></a>适用数据范围：</h3><p>数值型和标称型。</p></li><li><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3></li></ul><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*</span><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> operator<span class="hljs-keyword">import</span> matplotlib<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> listdir<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createDataSet</span>():</span>    group = array([[<span class="hljs-number">1.0</span>, <span class="hljs-number">1.1</span>], [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>]])    labels = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]    <span class="hljs-keyword">return</span> group, labels<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify0</span>(<span class="hljs-params">inX, dataSet, labels, k</span>):</span>    dataSetSize = dataSet.shape[<span class="hljs-number">0</span>]    diffMat = tile(inX, (dataSetSize,<span class="hljs-number">1</span>),) - dataSet <span class="hljs-comment"># tile：获得dataSetSize行1列的 inX向量（横着）</span>    sqDiffMat = diffMat**<span class="hljs-number">2</span>    sqDistances = sqDiffMat.sum(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># axis=1：将一个矩阵的每一行向量内部相加</span>    distances = sqDistances**<span class="hljs-number">0.5</span>    sortedDistIndicies = distances.argsort()  <span class="hljs-comment"># argsort() 返回数组值从小到大的索引值</span>    classCount = &#123;&#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):        votelabel = labels[sortedDistIndicies[i]]        classCount[votelabel] = classCount.get(votelabel, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)    <span class="hljs-keyword">return</span> sortedClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-comment"># 将文本记录解析为为 训练样本矩阵，类标签向量</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file2matrix</span>(<span class="hljs-params">filename</span>):</span>    fr = open(filename)    arrayOfLines = fr.readlines()    <span class="hljs-comment"># 按行读</span>    numberOfLines = len(arrayOfLines)    returnMat = zeros((numberOfLines, <span class="hljs-number">3</span>))    classLabelVector = []    index = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> arrayOfLines:        line = line.strip() <span class="hljs-comment"># 截取掉所有的回车字符</span>        listFromLine = line.split(<span class="hljs-string">&#x27;\t&#x27;</span>)     <span class="hljs-comment"># 使用tab字符将整行数据分割成一个元素列表</span>        returnMat[index, :] = listFromLine[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]        classLabelVector.append(int(listFromLine[<span class="hljs-number">-1</span>]))        index += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> returnMat, classLabelVector<span class="hljs-comment"># datingDataMat, datingLables = file2matrix(&#x27;datingTestSet2.txt&#x27;)</span><span class="hljs-comment"># fig = plt.figure()</span><span class="hljs-comment"># ax = fig.add_subplot(111)</span><span class="hljs-comment"># ax.scatter(datingDataMat[:,0], datingDataMat[:,1], 15.0*array(datingLables), 15.0*array(datingLables))</span><span class="hljs-comment"># plt.show()</span><span class="hljs-comment"># 归一化特征值</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">autoNorm</span>(<span class="hljs-params">dataSet</span>):</span>    minVals = dataSet.min(<span class="hljs-number">0</span>)    <span class="hljs-comment"># min(0)返回该矩阵中每一列的最小值 / min(1)返回该矩阵中每一行的最小值</span>    maxVals = dataSet.max(<span class="hljs-number">0</span>)    ranges = maxVals - minVals    normDataSet = zeros(shape(dataSet))    m = dataSet.shape[<span class="hljs-number">0</span>]    normDataSet = dataSet - tile(minVals, (m,<span class="hljs-number">1</span>))    normDataSet = normDataSet / tile(ranges, (m,<span class="hljs-number">1</span>))    <span class="hljs-keyword">return</span> normDataSet, ranges, minVals<span class="hljs-comment"># normMat, ranges, minVals = autoNorm(datingDataMat)</span><span class="hljs-comment"># 测试集的错误率</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">datingClassTest</span>():</span>    hoRatio = <span class="hljs-number">0.10</span>    datingDataMat, datingLables = file2matrix(<span class="hljs-string">&#x27;datingTestSet2.txt&#x27;</span>)    normMat, ranges, minVals = autoNorm(datingDataMat)    m = normMat.shape[<span class="hljs-number">0</span>]    numTestVecs = int(m*hoRatio)    errorCount = <span class="hljs-number">0.0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(numTestVecs):        classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], datingLables[numTestVecs:m], <span class="hljs-number">3</span>)        print(<span class="hljs-string">&quot;the classifier came back with: %d, the real answer is: %d&quot;</span> % (classifierResult, datingLables[i]))        <span class="hljs-keyword">if</span>(classifierResult != datingLables[i]): errorCount += <span class="hljs-number">1.0</span>    print(<span class="hljs-string">&quot;the total error rate is: %f&quot;</span> % (errorCount/float(numTestVecs)))<span class="hljs-comment"># 预测具体的人</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classifyPerson</span>():</span>    resultList = [<span class="hljs-string">&#x27;not at all&#x27;</span>, <span class="hljs-string">&#x27;in small doses&#x27;</span>, <span class="hljs-string">&#x27;in large doses&#x27;</span>]    percentTats = float(input(<span class="hljs-string">&quot;percentage of time spent playing video games?&quot;</span>))    ffMiles = float(input(<span class="hljs-string">&quot;frequent flier miles earned per year?&quot;</span>))    iceCream = float(input(<span class="hljs-string">&quot;liters of ice cream consumed per year?&quot;</span>))    datingDataMat, datingLables = file2matrix(<span class="hljs-string">&quot;datingTestSet2.txt&quot;</span>)    normMat, ranges, minVals = autoNorm(datingDataMat)    inArr = array([percentTats, ffMiles, iceCream])    classifierResult = classify0((inArr-minVals)/ranges, normMat,datingLables,<span class="hljs-number">3</span>)    print(<span class="hljs-string">&quot;You will probably like this person: &quot;</span>, resultList[classifierResult<span class="hljs-number">-1</span>])<span class="hljs-comment"># 准备数据（将32*32的二进制图像矩阵转换为1*1024的向量）</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">img2vector</span>(<span class="hljs-params">filename</span>):</span>    returnVect = zeros((<span class="hljs-number">1</span>, <span class="hljs-number">1024</span>))    fr = open(filename)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>):        lineStr = fr.readline()        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>):            returnVect[<span class="hljs-number">0</span>, <span class="hljs-number">32</span>*i+j] = int(lineStr[j])    <span class="hljs-keyword">return</span> returnVect<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handwritingClassTest</span>():</span>    hwLabels = []   <span class="hljs-comment"># 标签集</span>    trainingFileList = listdir(<span class="hljs-string">&#x27;trainingDigits&#x27;</span>)    <span class="hljs-comment"># 列出给定目录下的文件名</span>    m = len(trainingFileList)    trainingMat = zeros((m, <span class="hljs-number">1024</span>))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):        fileNameStr = trainingFileList[i]   <span class="hljs-comment"># 文件名 如&#x27;9_45.txt&#x27;,数字9的第45个实例</span>        fileStr = fileNameStr.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment"># &#x27;9_45&#x27;</span>        classNumStr = int(fileStr.split(<span class="hljs-string">&#x27;_&#x27;</span>)[<span class="hljs-number">0</span>])   <span class="hljs-comment"># 9</span>        hwLabels.append(classNumStr)        trainingMat[i,:] = img2vector(<span class="hljs-string">&#x27;trainingDigits/%s&#x27;</span> % fileNameStr)    testFileList = listdir(<span class="hljs-string">&#x27;testDigits&#x27;</span>)    errorCount = <span class="hljs-number">0.0</span>    mTest = len(testFileList)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(mTest):        fileNameStr = testFileList[i]        fileStr = fileNameStr.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]        classNumStr = int(fileStr.split(<span class="hljs-string">&#x27;_&#x27;</span>)[<span class="hljs-number">0</span>])        vectorUnderTest = img2vector(<span class="hljs-string">&#x27;testDigits/%s&#x27;</span> % fileNameStr)        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="hljs-number">3</span>)        print(<span class="hljs-string">&quot;the classifier came back with: %d, the real answer is: %d&quot;</span> % (classifierResult, classNumStr))        <span class="hljs-keyword">if</span>(classifierResult != classNumStr):    errorCount += <span class="hljs-number">1.0</span>    print(<span class="hljs-string">&quot;\nthe total number of errors is: %d&quot;</span> % errorCount)    print(<span class="hljs-string">&quot;\nthe total error rate is: %f&quot;</span> % (errorCount/float(mTest)))</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分类算法</tag>
      
      <tag>有监督学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris树遍历算法</title>
    <link href="/2020/09/24/Morris%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/24/Morris%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文主要解决一个问题，如何实现二叉树的前中后序遍历，并满足以下要求：</p><ul><li>空间复杂度为O(1)；</li><li>二叉树的形状不能被破坏（中间过程允许改变其形状）。</li></ul><p>通常情况下，我们使用递归和迭代的方式进行遍历。但是由于这两种方式会用到递归栈或用户自定义栈等，空间复杂度为O(n)，均不满足上述要求。</p><p><strong>Morris Traversal</strong>方法可以满足上述两个要求，只需要O(1)的空间复杂度，同时在O(n)时间复杂度内完成遍历。</p><h4 id="一、中序遍历"><a href="#一、中序遍历" class="headerlink" title="一、中序遍历"></a>一、中序遍历</h4><p>我们在中序遍历的时候，一定先遍历左子树，然后遍历当前节点，最后遍历右子树。我们需要一种巧妙地方法可以在O(1)的空间下，遍历完左子树后可以再回到当前节点。我们希望当前节点在遍历完当前节点的前驱之后被遍历，我们可以考虑修改前驱的right指针。当前节点的前驱节点的right指针可能本来就指向当前节点（前驱是当前节点的父节点），也可能是当前节点左子树最右下的节点。如果是后者，我们希望遍历完这个前驱节点后再回到当前节点，可以将它的right指针指向当前节点。</p><p>Morris中序遍历的一个重要步骤就是寻找当前节点的前驱节点，并且Morris中序遍历寻找下一个点始终是通过转移到right指针指向的位置来完成的。</p><ul><li>如果当前节点没有左子树，则遍历这个点，然后跳转到当前节点的右子树。</li><li>如果当前节点有左子树，那么它的前驱节点一定在左子树上，我们可以在左子树上一直向右行走，找到当前点的前驱节点。<ul><li>如果前驱节点没有右子树，就将前驱节点的right指针指向当前节点。这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点。</li><li>如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并修改了right指针，这个时候我们重新将前驱的右孩子设置为空，遍历当前节点，然后跳转到当前节点的右子树。</li></ul></li></ul><p>我们可以得到这样的代码框架：</p><pre><code class="hljs c++">Treenode* cur = root, *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">while</span> (cur) &#123;    <span class="hljs-keyword">if</span> (!cur-&gt;left) &#123;        <span class="hljs-comment">// ...遍历cur</span>        cur = cur-&gt;right;        <span class="hljs-keyword">continue</span>;    &#125;        pre = cur-&gt;left;    <span class="hljs-keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) &#123;        pre = pre-&gt;right;    &#125;        <span class="hljs-keyword">if</span> (!pre-&gt;right) &#123;        pre-&gt;right = cur;        cur = cur-&gt;left;    &#125;    <span class="hljs-keyword">if</span> (pre-&gt;right == cur) &#123;        pre-&gt;right = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">// ...遍历cur</span>        cur = cur-&gt;right;       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList集合</title>
    <link href="/2020/08/12/ArrayList%E9%9B%86%E5%90%88/"/>
    <url>/2020/08/12/ArrayList%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList当中的常用方法有："><a href="#ArrayList当中的常用方法有：" class="headerlink" title="ArrayList当中的常用方法有："></a>ArrayList当中的常用方法有：</h3><ul><li><code>public boolean add(E e)</code>：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。  </li></ul><p><strong>备注：</strong>对于<em>ArrayList</em>集合来说，<em>add</em>添加动作一定是成功的，所以返回值可用可不用。 （但对于其他集合来说，<em>add</em>添加动作不一定成功）。  </p><ul><li><code>public E get(int index)</code>：从集合当中获取元素，参数是索引编号（从0开始），返回值就是对应位置的元素。  </li><li><code>public E remove(int index)</code>：从集合当中删除元素，参数是索引编号（从0开始），返回值就是被删除的元素。</li><li><code>public int size()</code>：获取集合的尺寸长度，返回值是集合中包含的元素个数。  </li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03ArrayListMethod</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        System.out.println(list);   <span class="hljs-comment">// []</span>        <span class="hljs-comment">// 向集合中添加元素: add</span>        <span class="hljs-keyword">boolean</span> success = list.add(<span class="hljs-string">&quot;aaa&quot;</span>);        System.out.println(list);   <span class="hljs-comment">// [aaa]</span>        System.out.println(<span class="hljs-string">&quot;添加的动作是否成功： &quot;</span> + success);    <span class="hljs-comment">// true</span>        list.add(<span class="hljs-string">&quot;bbb&quot;</span>);        list.add(<span class="hljs-string">&quot;ccc&quot;</span>);        list.add(<span class="hljs-string">&quot;ddd&quot;</span>);        list.add(<span class="hljs-string">&quot;eee&quot;</span>);        System.out.println(list);   <span class="hljs-comment">// [aaa, bbb, ccc, ddd, eee]</span>        <span class="hljs-comment">// 从集合中获取元素： get。 索引值从0开始</span>        String name = list.get(<span class="hljs-number">2</span>);        System.out.println(<span class="hljs-string">&quot;第2号索引位置： &quot;</span> + name);  <span class="hljs-comment">// ccc</span>        <span class="hljs-comment">// 从集合中删除元素： remove。 索引值从0开始</span>        String whoRemoved = list.remove(<span class="hljs-number">3</span>);        System.out.println(<span class="hljs-string">&quot;被删除的人是： &quot;</span> + whoRemoved);    <span class="hljs-comment">// ddd</span>        System.out.println(list);   <span class="hljs-comment">// [aaa, bbb, ccc, eee]</span>        <span class="hljs-comment">// 获取集合的长度尺寸，也就是其中元素的个数</span>        <span class="hljs-keyword">int</span> size = list.size();        System.out.println(<span class="hljs-string">&quot;集合的长度是： &quot;</span> + size);    &#125;&#125;</code></pre><h3 id="ArrayList集合存储基本数据："><a href="#ArrayList集合存储基本数据：" class="headerlink" title="ArrayList集合存储基本数据："></a>ArrayList集合存储基本数据：</h3><p>如果希望集合<em>ArrayList</em>当中存储基本类型数据，必须使用基本类型对应的“包装类”。  </p><table><thead><tr><th align="center">基本类型</th><th align="center">包装类（引用类型，包装类都位于java.lang包下）</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><p>从JDK 1.5+开始，支持自动装箱、自动拆箱。</p><ul><li>自动装箱：基本类型 ——&gt; 包装类型</li><li>自动拆箱：包装类型 ——&gt; 基本类型</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05ArrayListBasic</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ArrayList&lt;String&gt; listA = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 错误写法！ 泛型只能是引用类型，不能是基本类型</span><span class="hljs-comment">//        ArrayList&lt;int&gt; listB = new ArrayList&lt;int&gt;();</span>        ArrayList&lt;Integer&gt; listC = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        listC.add(<span class="hljs-number">100</span>);        listC.add(<span class="hljs-number">200</span>);        System.out.println(listC);  <span class="hljs-comment">// [100, 200]</span>        <span class="hljs-keyword">int</span> num = listC.get(<span class="hljs-number">1</span>);        System.out.println(num);    <span class="hljs-comment">// 200</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定义一个标准的类</title>
    <link href="/2020/08/11/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB/"/>
    <url>/2020/08/11/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>一个标准的类通常要拥有下面四个组成部分：</p><ol><li>所有的成员变量都要使用<code>private</code>关键字修饰</li><li>为每一个成员变量编写一对<em>Getter/Setter</em>方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员变量与局部变量的区别</title>
    <link href="/2020/08/03/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/08/03/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="局部变量和成员变量"><a href="#局部变量和成员变量" class="headerlink" title="局部变量和成员变量"></a>局部变量和成员变量</h3><ol><li>定义的位置不一样<strong>【重点】</strong> </li></ol><p>&emsp;局部变量：在方法的内部  </p><p>&emsp;成员变量：在方法的外部，直接写在类当中  </p><ol start="2"><li>作用范围不一样<strong>【重点】</strong>  </li></ol><p>&emsp;局部变量：只有方法当中才可以使用，出了方法就不能再用  </p><p>&emsp;成员变量：整个类全都可以通用  </p><ol start="3"><li>默认值不一样<strong>【重点】</strong>  </li></ol><p>&emsp;局部变量：没有默认值，如果要使用，必须手动进行赋值  </p><p>&emsp;成员变量：如果没有赋值，会有默认值，规则和数组一样  </p><ol start="4"><li>内存的位置不一样（了解）  </li></ol><p>&emsp;局部变量：位于栈内存  </p><p>&emsp;成员变量：位于堆内存  </p><ol start="5"><li>生命周期不一样（了解）  </li></ol><p>&emsp;局部变量：随着方法进栈而诞生，随着方法出栈而消失  </p><p>&emsp;成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失  </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01VariableDifference</span> </span>&#123;    String name;    <span class="hljs-comment">// 成员变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 局部变量</span>        System.out.println(num);        System.out.println(name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> param)</span> </span>&#123;    <span class="hljs-comment">// 方法的参数就是局部变量</span>        <span class="hljs-comment">// 参数在方法调用的时候，必然会被赋值的</span>        System.out.println(param);        <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">// 局部变量</span><span class="hljs-comment">//        System.out.println(age);    // 没赋值不能用，会报错</span><span class="hljs-comment">//        System.out.println(num);    // 错误写法 e</span>        System.out.println(name);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的内存划分</title>
    <link href="/2020/07/23/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <url>/2020/07/23/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Java的内存需要划分成为5个部分："><a href="#Java的内存需要划分成为5个部分：" class="headerlink" title="Java的内存需要划分成为5个部分："></a>Java的内存需要划分成为5个部分：</h3><ol><li><p><strong>栈（stack）：</strong>存放的是方法中的局部变量。<font color = "red">方法的运行一定要在栈当中运行。</font>  </p></li><li><p><strong>堆（Heap）：</strong><font color = "red">凡是<code>new</code>出来的东西，都在堆当中。</font>    </p><p>&emsp; &emsp; 堆内存里面的东西都有一个地址值：16进制      </p><p>&emsp; &emsp; 堆内存里面的数据，都有默认值。规则：  </p></li></ol><a id="more"></a><table><thead><tr><th align="center">数据类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">如果是整数</td><td align="center">默认为0</td></tr><tr><td align="center">如果是浮点数</td><td align="center">默认为0.0</td></tr><tr><td align="center">如果是字符</td><td align="center">默认为’\u0000’</td></tr><tr><td align="center">如果是布尔</td><td align="center">默认为false</td></tr><tr><td align="center">如果是引用类型</td><td align="center">默认为null</td></tr></tbody></table><ol start="3"><li><strong>方法区（Method Area）：</strong>存储<code>.class</code>相关信息，包含方法的信息。  </li><li>本地方法栈（Native Method Stack）：与操作系统相关。   </li><li>寄存器（pc Register）：与<code>CPU</code>相关。    </li></ol><h3 id="一个数组的内存图示例："><a href="#一个数组的内存图示例：" class="headerlink" title="一个数组的内存图示例："></a>一个数组的内存图示例：</h3><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200723224304.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法重载</title>
    <link href="/2020/07/22/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    <url>/2020/07/22/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名，太麻烦。  </p><p><strong>方法的重载（overload）：</strong>多个方法的名称一样，但是<strong>参数列表</strong>不一样。  </p><p>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。  </p><h4 id="方法的重载与下列因素相关："><a href="#方法的重载与下列因素相关：" class="headerlink" title="方法的重载与下列因素相关："></a>方法的重载与下列因素相关：</h4><ol><li>参数个数不同  </li><li>参数类型不同  </li><li>参数的多类型顺序不同</li></ol><h4 id="方法的重载与下列因素无关："><a href="#方法的重载与下列因素无关：" class="headerlink" title="方法的重载与下列因素无关："></a>方法的重载与下列因素无关：</h4><ol><li>与参数的名称无关</li><li>与参数的返回值类型无关  </li></ol><a id="more"></a><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));  <span class="hljs-comment">// 30</span>        System.out.println(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>));  <span class="hljs-comment">// 60</span>        System.out.println(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>));  <span class="hljs-comment">// 100</span>    &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">double</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (a + b);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (a + b);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;  <span class="hljs-comment">/*   错误写法！！ 与方法的返回值类型无关</span><span class="hljs-comment">    public static double sum(int a, int b) &#123;</span><span class="hljs-comment">return a + b + 0.0;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    */</span>  <span class="hljs-comment">/*   错误写法！！ 与参数的名称无关</span><span class="hljs-comment">    public static int sum(int x, int y) &#123;</span><span class="hljs-comment">        return x + y;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b + c;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b + c + d;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA常用快捷键</title>
    <link href="/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><table><thead><tr><th>快捷键</th><th align="left">功能</th></tr></thead><tbody><tr><td><code>Alt + Enter</code></td><td align="left">导入包，自动修正代码</td></tr><tr><td><code>Ctrl + Y</code></td><td align="left">删除光标所在行</td></tr><tr><td><code>Ctrl + D</code></td><td align="left">复制光标所在行的内容，插入光标位置下面</td></tr><tr><td><code>Ctrl + Alt + L</code></td><td align="left">格式化代码</td></tr><tr><td><code>Ctrl + /</code></td><td align="left">单行注释，再按取消注释</td></tr><tr><td><code>Ctrl + Shift + /</code></td><td align="left">选中代码注释，多行注释，再按取消注释</td></tr><tr><td><code>Alt + Ins</code></td><td align="left">自动生成代码， toString，Get，set等方法</td></tr><tr><td><code>Alt + Shift + 上下箭头</code></td><td align="left">移动当前代码行</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找算法</title>
    <link href="/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="二分查找的思想"><a href="#二分查找的思想" class="headerlink" title="二分查找的思想"></a>二分查找的思想</h3><p>减而治之，即将大规模问题转化成小规模问题。减而治之是分而治之的特例，将大问题划分成若干个子问题以后，最终答案只在其中一个子问题里。  </p><h3 id="二分查找的基本问题（二分查找模板一）"><a href="#二分查找的基本问题（二分查找模板一）" class="headerlink" title="二分查找的基本问题（二分查找模板一）"></a>二分查找的基本问题（二分查找模板一）</h3><a id="more"></a><p>[LeetCode] 第704题：<a href="https://leetcode-cn.com/problems/binary-search/">二分查找</a>  </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == target)<span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)left = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>right = mid - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre><p>说明：</p><ol><li>循环可以继续的条件是<code>while(left &lt;= right)</code>， 表示当<code>left==right</code>成立时，还有一个元素，即下标<code>left(right)</code>位置的元素还没有看到，需要继续查看这个元素的值，看看是不是目标元素；</li><li>关于取中间数<code>int mid = (left + right) / 2;</code>在<code>left + right</code>很大的时候会发生整型溢出，一般这样改写：  </li></ol><p><code>int mid = left + (right - left) / 2;</code></p><p>这两种写法事实上没有太大区别，在<code>left</code>和<code>right</code>都表示数组下标的时候，几乎不会越界，因为绝大多是情况下不会开那么长的数组。  </p><p>这里不建议把<code>/2</code>改写成<code>&gt;&gt;1</code>，理由是**高级语言在编译期间会做优化，会将<code>2</code>，以及除以2的方幂的操作，在内部修改为<code>&gt;&gt;</code>**，工程师只需要写程序本来的逻辑就好了。如果使用位运算，在C++中可能还需要注意运算优先级的问题。  </p><ol start="3"><li>还有一个细节，<code>/2</code>表示的是下取整，当数组中的元素个数为偶数的时候，<code>int mid = left + (right - left) / 2;</code>只能取到位于左边的那个元素。取右边中间数的表达式是（其实就是在括号里+1，表示上取整）：<code>int mid = left + (right - left) / 2;</code>  </li></ol><p>以上代码可以认为是二分查找的模板一。  </p><h3 id="二分查找模板二（在循环体里排除不存在目标元素的区间）"><a href="#二分查找模板二（在循环体里排除不存在目标元素的区间）" class="headerlink" title="二分查找模板二（在循环体里排除不存在目标元素的区间）"></a>二分查找模板二（在循环体里排除不存在目标元素的区间）</h3><p>说明：这个模板的难点在于<strong>理解根据分支决定取中间数是上取整还是下取整，以避免死循环。</strong>  </p><p>我们上面有提到过，上取整还是下取整理应同样对待，但是在这个模板里为了避免死循环就有所区分。这一点理解清楚以后，解决二分查找问题就不会很难了。  </p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从考虑哪些元素一定不是目标元素开始考虑：<strong>根据看到的<code>mid</code>位置的元素，排除掉一定不可能存在目标元素的区间，而下一轮在可能存在目标的子区间里继续查找。</strong>  </p><h4 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h4><ol><li>先把循环可以继续的条件携程<code>while(left &lt; right)</code>，表示退出循环的时候，<code>[left, right]</code>这个区间里只有一个元素，这个元素<strong>有可能</strong>就是目标元素；  </li><li>写<code>if</code>和<code>else</code>语句时，思考当<code>nums[mid]</code>满足什么性质的时候，<code>nums[mid]</code>不是解，进而接着判断<code>mid</code>的左边有没有可能是解，<code>mid</code>的右边有没有可能是解；</li></ol><h4 id="理解如何避免死循环（重难点）"><a href="#理解如何避免死循环（重难点）" class="headerlink" title="理解如何避免死循环（重难点）"></a>理解如何避免死循环（重难点）</h4><p>根据<code>mid</code>被分到左边区间还是右边区间，代码写出来只有以下2种：  </p><p><strong>边界收缩行为1：</strong><code>mid</code>被分到左边。即区间被分成<code>[left, mid]</code>于<code>[mid+1, right]</code>，这里用[闭区间]表示区间端点可以取到，下同；  </p><p>代码写出来是这样的：  </p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (check(mid)) &#123;<span class="hljs-comment">// 下一轮搜索区间是 [mid+1, right]</span>left = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;right = mid;&#125;</code></pre><p><strong>边界收缩行为2：</strong><code>mid</code>被分到右边。即区间被分成<code>[left, mid - 1]</code>与<code>[mid, right]</code>;</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (check(mid)) &#123;    right = mid - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> &#123;left = mid;&#125;</code></pre><p>面对上面的<strong>边界收缩行为2</strong>（<code>mid</code>被分到右边），在待搜索区间收缩到只剩下2个元素的时候，<strong>就有可能造成死循环。搜索区间不能缩小，是造成死循环的原因</strong>。  </p><p>有了上面的分析，我们把上面 [边界收缩行为] 对应的中间数取法补上：    </p><p><strong>边界收缩行为1：</strong><code>mid</code>被分到左边。即区间被分成<code>[left, mid]</code>与<code>[mid + 1, right]</code>，此时取中间数的时候下取整。  </p><pre><code class="hljs vbscript"><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(check(<span class="hljs-built_in">mid</span>)) &#123;<span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;&#125;</code></pre><p><strong>边界收缩行为2：</strong><code>mid</code>被分到右边。即区间被分为<code>[left, mid - 1]</code>与<code>[mid, right]</code>，此时取中间数的时候<strong>上取整</strong>。  </p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (check(mid)) &#123;right = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;left = mid;&#125;</code></pre><p>规则：<strong>在<code>if</code> <code>else</code>语句里面只要出现<code>left = mid</code>的时候，把取中间数行为改成上取整即可</strong>。    </p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法——归并排序</title>
    <link href="/2020/07/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>设归并排序的当前区间为<code>R[low...high]</code>，分治法的三个步骤是：  </p><ul><li>分解：将当前区间一分为二，即求分裂点  </li><li>求解：递归地对两个子区间<code>R[low...mid]</code>和<code>R[mid+1...high]</code>进行归并排序  </li><li>组合：将已排序的两个子区间<code>R[low...mid]</code>和<code>R[mid+1...high]</code>归并为一个有序的区间<code>R[low...high]</code>  </li></ul><p>递归的终结条件：子区间的长度为1  </p><a id="more"></a><h4 id="算法示意图："><a href="#算法示意图：" class="headerlink" title="算法示意图："></a>算法示意图：</h4><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200712235803.png"></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span></span>&#123;<span class="hljs-keyword">int</span> left_start = low, left_len = (high - low) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right_start = low + left_len;        <span class="hljs-keyword">int</span> cnt = low;        <span class="hljs-keyword">while</span>(left_start &lt; low + left_len &amp;&amp; right_start &lt; high + <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(nums[left_start] &lt; nums[right_start])result[cnt++] = nums[left_start++];            <span class="hljs-keyword">else</span>result[cnt++] = nums[right_start++];        &#125;        <span class="hljs-keyword">while</span>(left_start &lt; low + left_len)result[cnt++] = nums[left_start++];        <span class="hljs-keyword">while</span>(right_start &lt; high + <span class="hljs-number">1</span>)result[cnt++] = nums[right_start++];    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span></span>&#123;<span class="hljs-keyword">if</span>(low &lt; high)&#123;<span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;            mergeSort(nums, low, mid, result);            mergeSort(nums, mid+<span class="hljs-number">1</span>, high, result);            merge(nums, low, high, result);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++)nums[i] = result[i];        &#125;    &#125;&#125;;</code></pre><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li>时间复杂度：</li></ul><p>最差时间复杂度： O(nlogn)</p><p>平均时间复杂度：O(nlogn)</p><ul><li>空间复杂度：</li></ul><p>最差空间复杂度：O(n)</p><p>稳定性：稳定</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>经典排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法——快速排序</title>
    <link href="/2020/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>快速排序，<strong>即选定基准数据并找出其正确索引位置的过程</strong>。</p><p>通过使用<strong>分治思想</strong>对快速排序算法进行描述。下面对一个典型的子数组<code>nums[p...r]</code>进行快速排序的三步分治过程：  </p><p>&emsp; <strong>分解：</strong>数组<code>nums[p...r]</code>被划分为两个（可能为空）子数组<code>nums[p...q-1]</code>和<code>nums[q+1...r]</code>，使得<code>nums[p...q-1]</code>中的每个元素都小于<code>nums[q]</code>，而<code>nums[q+1...r]</code>中的每个元素都大于<code>nums[q]</code>。</p><p>&emsp; <strong>解决：</strong>通过递归调用快速排序，对数组<code>nums[p...q-1]</code>和<code>nums[q+1...r]</code>进行排序。</p><p>&emsp; <strong>合并：</strong>因为子数组都是原址排序的，所以不需要合并操作：数组<code>nums[p...r]</code>已经有序。</p><p>下面以一个实例来描述快速排序的过程。 </p><a id="more"></a><p>如下图所示，假设最开始的基准数据为数组第一个元素23，则首先用一个临时变量取存储基准数据，即tmp = 23；然后分别从数组的两端扫描数组，设两个指示标志：low指向起始位置，high指向末尾位置。</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708185112.png"></p><p>首先从<strong>后半部分</strong>开始比较，如果扫描到的值大于基准数据就让high-1，如果发现有元素比基准元素值小（如上图18&lt;=tmp），就将high位置的值赋值给low位置。</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708191132.png"></p><p><strong>然后开始从前往后扫描</strong>，如果扫描到的元素小于基准元素，则low+1；如果发现有元素大于基准元素的值(如上图46 &gt;= tmp)，就将low位置的值赋值给high位置。指针移动并且数据交换后的结果如下所示：</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708191511.png"></p><p>然后再开始从后往前扫描，原理同上，发现11 &lt;= tmp，则将high位置的值赋给low位置，结果如下：</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708192100.png"></p><p>然后再从前往后扫描，直到<strong>low==high</strong>结束循环，此时low或者high的下标就是基准数据23在该数组中的正确索引位置，如下图所示：  </p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708211026.png"></p><p>这样一遍走下来，就可以确定一个元素的位置，以后采用递归的方式，分别对前半部分和后半部分排序。</p><h4 id="几个要点："><a href="#几个要点：" class="headerlink" title="几个要点："></a>几个要点：</h4><ul><li>确定基准元素后，先从<code>high</code>向前开始比较。</li><li>在遍历比较时，判断是否满足<code>&gt;=</code>或<code>&lt;=</code>，即等于时不用交换。</li><li>循环结束的条件为<code>low&gt;=high</code>。循环结束后，需要将基准元素值写入当前的<code>low</code>或<code>high</code>位置。</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[low];<span class="hljs-comment">// 设置基准数据</span>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= tmp)high--;            nums[low] = nums[high];            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= tmp)low++;            nums[high] = nums[low];        &#125;        nums[low] = tmp;        <span class="hljs-keyword">return</span> low;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">if</span>(low &lt; high)&#123;<span class="hljs-keyword">int</span> mid = partition(nums, low, high);            quickSort(nums, low, mid<span class="hljs-number">-1</span>);            quickSort(nums, mid+<span class="hljs-number">1</span>, high);        &#125;    &#125;&#125;;</code></pre><h4 id="随机快速排序："><a href="#随机快速排序：" class="headerlink" title="随机快速排序："></a>随机快速排序：</h4><p>随机快排在确定基准元素时，采用一种随机抽样的随机化技术，使得从数组<code>nums[l...r]</code>中随机选取一个元素作为基准元素。由于基准元素的选取是随机的，舍得对输入数组的划分也是比较均衡的，从而获得较好的期望性能。  </p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[low];        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= tmp)high--;            nums[low] = nums[high];            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= tmp)low++;            nums[high] = nums[low];        &#125;        nums[low] = tmp;        <span class="hljs-keyword">return</span> low;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">random_partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-keyword">int</span> n = rand() % (high - low) + low;<span class="hljs-comment">// 随机选取下标</span>        swap(nums[low], nums[n]);<span class="hljs-comment">// 与low位置交换</span>        <span class="hljs-keyword">return</span> partition(nums, low, high);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-keyword">if</span>(low &lt; high)&#123;<span class="hljs-keyword">int</span> mid = random_partition(nums, low, high);            quickSort(nums, low, mid<span class="hljs-number">-1</span>);            quickSort(nums, mid+<span class="hljs-number">1</span>, high);        &#125;    &#125;&#125;;</code></pre><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p>时间复杂度：</p><p>考虑到最好情况，每次都是均匀划分，则时间复杂度为<code>O(nlgn)</code>。</p><p>但如果是最坏情况，比如[1,2,3,4,5]，复杂度变为<code>O(n^2)</code>。</p></li><li><p>空间复杂度：</p><p>这里分析就地快速排序的空间复杂度。首先就地快速排序使用的空间是<code>O(1)</code>的，也就是常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据。</p><p>最优的情况下空间复杂度为：<code>O(logn)</code>；每一次都平分数组的情况。</p><p>最差的情况下空间复杂度为：<code>O(n)</code>；退化为冒泡排序的情况。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>经典排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滚动数组</title>
    <link href="/2020/07/06/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"/>
    <url>/2020/07/06/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍一个十分实用的小技巧——滚动数组。它常被用来完成常数优化和减少代码量，且<strong>滚动数组思想</strong>是一种常见的动态规划优化方法。  </p><p>假设有如下状态转移方程：  </p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; dp[i][j] = max(dp[i-1][j+1], dp[i-1][j-1]);​</p><p>按照该状态转移方程，我们可以用二维数组保存其状态值，通过如下代码片段完成其状态的转移（这里仅做说明，不考虑边界情况）：  </p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);&#125;&#125;<span class="hljs-keyword">int</span> ans = dp[n][m];</code></pre><a id="more"></a><p>考虑到每次状态的转移仅与上一行有关（或以及本行已更新的部分），我们可以将二维数组优化到使用一维数组保存。如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;        buf[i] = <span class="hljs-built_in">max</span>(dp[j+<span class="hljs-number">1</span>], dp[j<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;dp[j] = buf[j];    &#125;&#125;<span class="hljs-keyword">int</span> ans = dp[m];</code></pre><p>如该代码片段所示，我们将原本二维的状态空间优化到了一维，对应的我们需要在每次状态转移过后进行依次循环次数为m的赋值操作。该操作不仅增加了代码量，还增加了程序的耗时。于是我们使用滚动数组，对其再次进行优化：  </p><p>定义大小为2*m的数组为其状态空间：  </p><p><code>int dp[2][m];</code>  </p><p>初始状态保存在dp[0][i]中。  </p><p>设定两个int类型指针  </p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *src; <span class="hljs-comment">//源指针</span><span class="hljs-keyword">int</span> *des; <span class="hljs-comment">//目的指针</span></code></pre><p>由于初始状态保存在dp数组的第0行中，初始时  </p><pre><code class="hljs c++">src = dp[<span class="hljs-number">1</span>];des = dp[<span class="hljs-number">0</span>];</code></pre><p>按照状态转移方程进行状态转移  </p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;swap(src, des); <span class="hljs-comment">//交换源指针和目的指针</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;des[j] = <span class="hljs-built_in">max</span>(src[j+<span class="hljs-number">1</span>], src[j<span class="hljs-number">-1</span>]);&#125;&#125;<span class="hljs-keyword">int</span> ans = des[m];</code></pre><p>如代码所示，我们在每次循环进行状态转移之前交换源数组和目的数组的指针，使程序能够正确的从源数组中转移状态到目的数组中。当状态转移完成时，新得到状态保存于目的数组中，但它在下一次循环的状态转移中又将变为源数组，于是我们在下次状态转移开始前再次交换源数组和目的数组指针，这就是滚动数组的工作原理。  </p><p>滚动数组这个技巧不仅优化了原始的状态空间，还减少了循环次数节约了程序运行时间，同时对代码量的缩减也有很好的效果，是一个值得学习的小技巧。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>41.缺失的第一个正数</title>
    <link href="/2020/06/27/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2020/06/27/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。   </p><p><strong>提示：</strong>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。  </p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>若不考虑时空复杂度，可以使用辅助空间记录出现的数字的方式实现，亦或者从<code>1</code>开始暴力比较每一个数组元素来实现。而按照题目中的要求，则需要尝试利用题目所给出的数组空间来协助完成。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><h5 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h5><p>考虑<code>n</code>个元素的整数数组，未出现的最小的正整数只可能在<code>[1, n+1]</code>。若<code>n</code>个元素存放了<code>[1,n]</code>的所有整数，则最小未出现的正数未<code>n+1</code>；否则，最小未出现的正数一定在<code>[1, n]</code>之间。我们使用负数来标记当前元素对应的下标的值存在。  </p><p>首先，先将原始数组中的负数全部变为<code>n+1</code>，因为若出现负数，则最小未出现正数一定不是<code>n+1</code>。全部变成正数后，就不会影响后面的标记操作。在遍历时，每次取当前元素的绝对值（这样我们既可以进行取负值标记，同时也保证了不破坏当前元素的原始值），若绝对值<code>x</code>在<code>[1, n]</code>之间，则将下标为<code>x-1</code>的元素值取反，表示<code>x</code>出现过。再进行一遍遍历，若当前下标<code>i</code>的元素值不为<code>i+1</code>则返回<code>i+1</code>；若均等于，则返回<code>n+1</code>。  </p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; num : nums)&#123;            <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;                num = n+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);            <span class="hljs-keyword">if</span>(num &lt;= n)&#123;                nums[num<span class="hljs-number">-1</span>] = -<span class="hljs-built_in">abs</span>(nums[num<span class="hljs-number">-1</span>]);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(n)，<code>n</code>为数组的长度。  </li><li>空间复杂度： O(1)。  </li></ul><h5 id="方法二：置换"><a href="#方法二：置换" class="headerlink" title="方法二：置换"></a>方法二：置换</h5><p>除了打标记，我们可以尝试将值为<code>x</code>的元素归位下标<code>x-1</code>。举个例子<code>[3, 4, -1, 1]</code>，归位后的数组应为<code>[1, -1, 3, 4]</code>，如此，我们就可以知道缺少的位置。  </p><p>对于<code>x = nums[i]</code>，若<code>x∈[1, n]</code>，则交换<code>nums[i]</code>和<code>nums[x-1]</code>的值。但是注意，若<code>nums[i] = x = nums[x-1]</code>则会陷入死循环，此时说明<code>x</code>已经位于正确的位置了，所以可以跳出循环，开始遍历下一个数。  </p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;                swap(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><h5 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(n)，<code>n</code>为数组的长度。  </li><li>空间复杂度： O(1)。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5441.保证文件名唯一</title>
    <link href="/2020/06/21/5441-%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80/"/>
    <url>/2020/06/21/5441-%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个长度为<code>n</code>的字符串数组<code>names</code>。你将会在文件系统中创建<code>n</code>个文件夹：在第<code>i</code>分钟，新建名为<code>names[i]</code>的文件夹。  </p><p>由于两个文件<strong>不能</strong>共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以<code>(k)</code>的形式为新文件夹的文件名添加后缀，其中<code>k</code>是能保证文件名唯一的<strong>最小正整数</strong>。  </p><p>返回长度为<code>n</code>的字符串数组，其中<code>ans[i]</code>是创建第<code>i</code>个文件夹时系统分配给该文件夹的实际名称。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>我们考虑使用一个<code>map</code>记录<code>&lt;当前文件名， 最小可用下标&gt;</code>，并用一个<code>vector</code>存储最终答案。先判断当前文件名是否出现过，如果未出现，则初始化<code>&lt;文件名， 1&gt;</code> 放入<code>map</code>中，同时，将对应文件名放入<code>vector</code>中；若当前文件名出现过，则从<code>map</code>中映射的最小可用下标开始向后枚举，得到第一个未被使用过的最小下标<code>i</code>，得到目标文件名<code>str</code>，存入答案数组中，并将<code>map</code>中对应文件名的最小可用下标更新至<code>i+1</code>，同时，将<code>&lt;str, 1&gt;</code>的映射关系存入<code>map</code>中。   </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">getFolderNames</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; names)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = names.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;  M;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-built_in">string</span> tmp = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">if</span>(M.<span class="hljs-built_in">find</span>(names[i]) == M.<span class="hljs-built_in">end</span>())&#123;                M[names[i]] = <span class="hljs-number">1</span>;                tmp = names[i];              &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">int</span> k = M[names[i]];                tmp =  names[i] + <span class="hljs-string">&#x27;(&#x27;</span> + to_string(k) + <span class="hljs-string">&#x27;)&#x27;</span>;                <span class="hljs-keyword">while</span>(M.<span class="hljs-built_in">find</span>(tmp) != M.<span class="hljs-built_in">end</span>())&#123;                    k++;                    tmp =  names[i] + <span class="hljs-string">&#x27;(&#x27;</span> + to_string(k) + <span class="hljs-string">&#x27;)&#x27;</span>;                &#125;                    M[names[i]] = k+<span class="hljs-number">1</span>;                M[tmp] = <span class="hljs-number">1</span>;            &#125;            res.push_back(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：只经过一遍数组元素的遍历，因此时间复杂度O(n)。  </li><li>空间复杂度： 创建了辅助空间<code>map</code>和<code>res</code>，因此空间复杂度O(n)。  </li></ul><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>起初对每个文件名的下标查找采用依次从1开始向后遍历，当一个文件名出现次数较多时，会有较多无用的搜索，从而导致了超时。因此，改进后采用记录当前可用的最小下标<code>i</code>，为了防止加上当前最小下标后的文件名在之前输入时已经出现过的情况，这里需要从此下标<code>i</code>开始向后寻找第一个没有使用过的下标。这样，可以避免每次都会重复访问<code>i</code>之前的下标，从而降低时间复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1014.最佳观光组合</title>
    <link href="/2020/06/17/1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/"/>
    <url>/2020/06/17/1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定正整数数组<code>A</code>，<code>A[i]</code>表示第<code>i</code>个观光景点的评分，并且两个景点<code>i</code>和<code>j</code>之间的距离为<code>j-i</code>。  </p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。  </p><p>返回一对观光景点能取得的最高分。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><h5 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h5><p>我们可以通过枚举任意两点之间的评分之和，然后取其中最高分，但是当数组元素较多时，会超时。  </p><h5 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h5><p>首先考虑如何优化上述遍历的双重循环问题，可以采用空间换时间的方法，通过一次遍历计算当前位置的最高分。  </p><p>我们观察得分公式为<code>A[i] + A[j] + i - j</code>，可以将其拆分成两部分<code>(A[i] + i) + (A[j] - j)</code>，先用两个数组预先保存对应下标<code>i</code>的<code>A[i] + i</code>和<code>A[i] - i</code>。接着进行一遍遍历，记录当前位置<code>j</code>之前的<code>A[i] + i</code>能得到的最大值，并与当前位置的<code>A[j] - j</code>相加，得到当前位置能取得的最大值，直到一遍遍历结束后，即可得到整体的最高分。下面展示状态转移方程：  </p><center>dp[j] = max(A[i] + i) + (A[j] - j)                  (i < j)</center><p><code>dp[j]</code>指在下标为j的位置可以得到的最高评分。  </p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">V1</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">V2</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            V1[i] = A[i] + i;            V2[i] = A[i] - i;         &#125;        <span class="hljs-keyword">int</span> x = V1[<span class="hljs-number">0</span>], ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            ans = <span class="hljs-built_in">max</span>(x + V2[i], ans);            x = <span class="hljs-built_in">max</span>(x, V1[i]);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：一遍元素的遍历，故时间复杂度为O(n)。  </li><li>空间复杂度：两个辅助空间<code>V1</code>和<code>V2</code>，故空间复杂度为O(n)。     </li></ul><h5 id="改进与优化"><a href="#改进与优化" class="headerlink" title="改进与优化"></a>改进与优化</h5><p>上述计算每个位置的最高得分，只与此前的最大<code>A[i] + i</code>以及当前位置的<code>A[j] - j</code>有关，因此，我们可以用两个变量来记录这两个值，从而减少了上述方法中辅助空间的使用。  </p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">int</span> x = A[<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            ans = <span class="hljs-built_in">max</span>(x + A[i] - i, ans);            x = <span class="hljs-built_in">max</span>(x, A[i] + i);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：一遍元素的遍历，故时间复杂度为O(n)。  </li><li>空间复杂度：常数个变量，故空间复杂度为O(1)。     </li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1477.找两个和为目标值且不重叠的子数组</title>
    <link href="/2020/06/15/1477-%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2020/06/15/1477-%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组<code>arr</code>和一个整数值<code>target</code>。  </p><p>请你在<code>arr</code>中找<strong>两个互不重叠的子数组</strong>且它们的和都等于<code>target</code>。可能会有多种方案，请你返回满足要求的两个子数组长度和的<strong>最小值</strong>。  </p><p>请返回满足要求的最小长度和，如多无法找到这样的两个子数组，请返回**-1**。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>如果存在多个以<code>i</code>下标结尾的子数组满足要求，则选择其中长度最短的那一个。因为如果一个较长的子数组可以作为答案中的一部分，换成一个较短的子数组，也同样成立，同时满足总和更短。（贪心的思想）  </p><ol><li><p>首先，使用一个<code>map</code>来记录<code>&lt;前缀和，结尾下标&gt;</code>的映射信息。一个<code>vector</code>记录当前下标之前满足要求的最短子数组长度。</p></li><li><p>利用<code>当前前缀和 - target</code>判断是否存在目标子数组区间。若存在，则得出对应子数组长度，并与当前位置之前的最短子数组长度比较，将较小值存入一个<code>vector</code>中；否则，则存入<code>0</code>。  </p></li><li><p>得到一个满足要求的最短子数组后，以该子数组的起始下标为结尾，搜索<code>vector</code>中是否存在满足要求的第二个子数组，若存在，则记录两子数组长度和，并与当前最短的两个子数组之和进行比较，取小。  </p></li><li><p>经过一轮遍历之后，输出结果。    </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSumOfLengths</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;       <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; M;<span class="hljs-comment">// 用于&lt;前缀和，结尾下标&gt;的映射</span>       <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;       <span class="hljs-keyword">int</span> ans = <span class="hljs-number">2e9</span>;       <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; len;<span class="hljs-comment">// 记录到每个位置，和为target的最短子数组的长度</span>       <span class="hljs-keyword">int</span> mi = <span class="hljs-number">0</span>;<span class="hljs-comment">// 当前满足和为target的最短子数组的长度</span>       M[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;           t += arr[i];           M[t] = i;           <span class="hljs-keyword">if</span>(M.count(t - target))&#123;               <span class="hljs-keyword">int</span> l = M[t-target];               <span class="hljs-keyword">int</span> x = i - l;               <span class="hljs-keyword">if</span>(mi == <span class="hljs-number">0</span>)  mi = x;               <span class="hljs-keyword">else</span> mi = <span class="hljs-built_in">min</span>(mi, x);               len.push_back(mi);               <span class="hljs-keyword">if</span>(l != <span class="hljs-number">-1</span> &amp;&amp; len[l] != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 不是第一个满足条件的子数组</span>   ans = <span class="hljs-built_in">min</span>(ans, len[l] + x);               &#125;           &#125;<span class="hljs-keyword">else</span>&#123;               len.push_back(mi);           &#125;       &#125;       <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">2e9</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;       <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：一轮循环遍历，时间复杂度为O(n)。  </p></li><li><p>空间复杂度：用于哈希映射的<code>map</code>，以及记录目标子数组长度的<code>vector</code>，故空间复杂度为O(n)。</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5437.不同整数的最少数目</title>
    <link href="/2020/06/14/5437-%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE/"/>
    <url>/2020/06/14/5437-%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组<code>arr</code>和一个整数<code>k</code>。现需要从数组中恰好移除<code>k</code>个元素，请找出移除后数组中不同整数的最少数目。  </p><h5 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h5><p>&emsp;&emsp;首先根据题意，最终要得到不同整数的最少数目，说明我们所删除的k个元素要尽可能的互不相同，也就是说优先删除出现次数最少的元素。<br>&emsp;&emsp;根据上述思路，这里我们选择使用map来完成&lt;数据, 出现次数&gt;的存储。然后通过按照出现次数递增的顺序进行删除即可。但是，map的有序性是指对key的排序，显然这里我们需要做的是对于map中的value排序。  </p><ul><li>方法一：使用map + vector实现对value的排序。  </li></ul><a id="more"></a><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> cmp(const pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;&amp; A, const pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;&amp; B)&#123; <span class="hljs-comment">//规定对于map元素中value的排序规则</span>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>second &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>second;   <span class="hljs-comment">// 按照second值从小到大排序</span>&#125;<span class="hljs-keyword">class</span> Solution &#123;public:    <span class="hljs-built_in">int</span> find<span class="hljs-constructor">LeastNumOfUniqueInts(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;        <span class="hljs-built_in">int</span> n = arr.size<span class="hljs-literal">()</span>;        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;        map&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; M;    <span class="hljs-comment">// 建立关于&lt;数据, 出现次数&gt;的映射关系</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>find(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-literal">()</span>)&#123;  <span class="hljs-comment">// 第一次出现</span>                M<span class="hljs-literal">[<span class="hljs-identifier">arr</span>[<span class="hljs-identifier">i</span>]</span>] = <span class="hljs-number">1</span>;                ans++;  <span class="hljs-comment">// ans用来记录不同数据的个数</span>            &#125;<span class="hljs-keyword">else</span>   M<span class="hljs-literal">[<span class="hljs-identifier">arr</span>[<span class="hljs-identifier">i</span>]</span>]++;        &#125;        vector&lt;pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; &gt; vec(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);    <span class="hljs-comment">// 将map中的内容转存到vector中</span>        sort(vec.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, vec.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, cmp);  <span class="hljs-comment">// 对线性的vector进行排序</span>        <span class="hljs-keyword">for</span>(auto it = vec.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; it != vec.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; it++)&#123;            k -= it-&gt;second;            <span class="hljs-keyword">if</span>(k &lt; <span class="hljs-number">0</span>)   break;  <span class="hljs-comment">// 如果减去所有出现的当前元素后，k&lt;0,则当前元素减不完</span>            <span class="hljs-keyword">if</span>(k<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;                ans--;                break;            &#125;            ans--;  <span class="hljs-comment">//从所有不同数据中减去当前数据</span>                    &#125;        return ans;    &#125;&#125;;</code></pre><ul><li>方法二：使用map + 优先队列实现对value的排序。(思路差不多，主要熟悉熟悉优先队列的使用）  </li></ul><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLeastNumOfUniqueInts</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)m[arr[i]]++;              <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : m)pq.push(&#123;x.second, x.first&#125;);        <span class="hljs-keyword">while</span>(k &amp;&amp; pq.<span class="hljs-built_in">size</span>()) &#123;          <span class="hljs-keyword">auto</span> t = pq.top();          <span class="hljs-keyword">if</span>(k &gt;= t.first)k -= t.first;          <span class="hljs-keyword">else</span><span class="hljs-keyword">break</span>;        &#125;        pq.pop();    &#125;    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">size</span>();&#125;;</code></pre><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：单层for循环，时间复杂度为O(n)。  </li><li>空间复杂度：map+vector或map+priority_queue，空间复杂度为O(n)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70.爬楼梯</title>
    <link href="/2020/06/13/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2020/06/13/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要n阶才能达到楼顶。<br>每次只能爬1阶或2阶。请问共有多少种不同的方法可以爬到楼顶？  </p><a id="more"></a><h3 id="思路与算法："><a href="#思路与算法：" class="headerlink" title="思路与算法："></a>思路与算法：</h3><p>我们用<code>dp[i]</code>来表示到第<code>i</code>阶的方案数，由于题目限制每次只能爬1阶或2阶，所以可以得到动态规划的转移方程：  </p><center> dp[i] = dp[i-1] + dp[i-2] </center>     <p>边界条件设置<code>dp[0] = 1, dp[1] = 1</code>。<br>由于每次计算只用到了第<code>i-1</code>阶和第<code>i-2</code>阶的数据，所以可以只设置三个变量来代替数组，从而降低空间复杂度。  </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;            p = q;            q = r;            r = p + q;        &#125;        <span class="hljs-keyword">return</span> r;    &#125;&#125;;   </code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：循环执行了n次，每次花费常数的时间代价，故时间复杂度为O(n)。  </li><li>空间复杂度：只用了常数个变量作为辅助空间，故空间复杂度为O(1)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
